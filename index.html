<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.25.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":"mac"},"fold":{"enable":true,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
<meta property="og:type" content="website">
<meta property="og:title" content="l1n6yun&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="l1n6yun&#39;s Blog">
<meta property="og:description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="l1n6yun">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>l1n6yun's Blog - 记录学习的技能和遇到的问题</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/7.2.0/pangu.umd.js" integrity="sha256-JnmRRnJK7DC6RQJbAJb6AXOM9OmWzS6z8eYultk/48Y=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>

  <script src="/js/third-party/pace.js" defer></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">l1n6yun's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习的技能和遇到的问题</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">332</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">114</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="l1n6yun"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">l1n6yun</p>
  <div class="site-description" itemprop="description">chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">332</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2wxbjZ5dW4=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;l1n6yun"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmwxbjZ5dW5AZ21haWwuY29t" title="E-Mail → mailto:l1n6yun@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/30/%E5%91%8A%E5%88%AB%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2%E7%84%A6%E8%99%91%EF%BC%81Smart-Input-Pro-%E8%AE%A9%E7%BC%96%E7%A0%81%E4%BD%93%E9%AA%8C%E4%B8%9D%E6%BB%91%E8%B5%B7%E9%A3%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="l1n6yun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="l1n6yun's Blog">
      <meta itemprop="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | l1n6yun's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/30/%E5%91%8A%E5%88%AB%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2%E7%84%A6%E8%99%91%EF%BC%81Smart-Input-Pro-%E8%AE%A9%E7%BC%96%E7%A0%81%E4%BD%93%E9%AA%8C%E4%B8%9D%E6%BB%91%E8%B5%B7%E9%A3%9E/" class="post-title-link" itemprop="url">告别输入法切换焦虑！Smart Input Pro 让编码体验丝滑起飞</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-30 17:01:11" itemprop="dateCreated datePublished" datetime="2025-10-30T17:01:11+08:00">2025-10-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img alt="Image" data-src="/images/pasted-86.png" width="200px"></p>

<h2 id="插件简介：重新定义编码输入体验"><a href="#插件简介：重新定义编码输入体验" class="headerlink" title="插件简介：重新定义编码输入体验"></a>插件简介：重新定义编码输入体验</h2><h3 id="1-开发者专属智能助手"><a href="#1-开发者专属智能助手" class="headerlink" title="1 开发者专属智能助手"></a>1 开发者专属智能助手</h3><p>身为开发者，日常在编码时，是不是常被输入法切换问题困扰？写代码时得用英文输入法，添加注释又得切换成中文输入法。反复按 Shift 键或使用组合快捷键，不仅麻烦，还容易打断思路。有时候，因为没注意输入法状态，输入一半才发现错了，只能删除重新输入 ，实在让人抓狂。</p>
<p>Smart Input Pro 就是一款专为解决这些痛点而生的插件，基于 IntelliJ 平台，在 IDEA、WebStorm、PyCharm 等这些大家日常开发常用的工具中，都可以安装使用。它就像一个贴心的智能助手，时刻监控你的输入场景，然后自动帮你在中英文输入法之间进行切换，从此你再也不用手动频繁切换输入法了。</p>
<h3 id="2-核心设计理念"><a href="#2-核心设计理念" class="headerlink" title="2 核心设计理念"></a>2 核心设计理念</h3><p>Smart Input Pro 之所以能实现如此智能的切换，得益于其 “场景感知 + 智能决策” 的先进架构。它就像一个聪明的观察者，会实时分析多个关键因素：</p>
<ul>
<li><p><strong>光标位置</strong>：精确判断你当前输入的位置是在代码区、注释区，还是字符串内。</p>
</li>
<li><p><strong>代码上下文</strong>：理解代码的语法结构，知道哪些地方应该是英文代码，哪些地方是中文注释 。比如，当它检测到你在注释区域（单行注释<code>//</code>、多行注释<code>/* */</code>、文档注释<code>/** */</code> ）时，就会自动切换至中文输入法，方便你撰写说明；而在代码区域，则自动切换至英文输入法，确保代码语法正确。</p>
</li>
<li><p><strong>操作行为</strong>：留意你的操作动作，比如当你打开 Git 提交框准备填写提交信息时，它能识别提交框焦点，自动切换为中文输入法；当你使用 IdeaVim 模式时，在 NORMAL 模式下自动切换英文，确保命令正确执行。</p>
</li>
</ul>
<p>通过综合分析这些因素，插件能够动态匹配最优输入法，整个过程自然流畅，让你在不知不觉中完成输入状态的切换，将全部的注意力都集中在代码逻辑本身，极大地提升了编码效率和专注度 。</p>
<h2 id="核心功能：全场景覆盖的智能输入方案"><a href="#核心功能：全场景覆盖的智能输入方案" class="headerlink" title="核心功能：全场景覆盖的智能输入方案"></a>核心功能：全场景覆盖的智能输入方案</h2><h3 id="1-场景化自动切换：精准捕捉输入需求"><a href="#1-场景化自动切换：精准捕捉输入需求" class="headerlink" title="1 场景化自动切换：精准捕捉输入需求"></a>1 场景化自动切换：精准捕捉输入需求</h3><p>Smart Input Pro 的场景化自动切换功能十分强大，能精准识别各种输入场景，自动帮你切换到最合适的输入法 。</p>
<p>在代码编辑区，当你进入代码编写区域时，插件会迅速反应，自动切换为英文输入法，杜绝中文输入法下误输入全角符号（如 “，”“。”）导致的编译错误，为代码的准确性提供保障。它支持 JavaScript、Java、Vue 等主流语言，对字符串字面量还能进行智能识别。比如，当你输入<code>nameEn=&quot;Tom&quot;</code> 时，它能判断这里应保持英文；而当输入<code>nameCn=&quot;小明&quot;</code> ，则会自动唤醒中文 ，就像一个熟悉你代码习惯的伙伴，默默帮你处理好输入法的细节。</p>
<p>来到注释与文档区，当你输入单行注释（&#x2F;&#x2F;）、多行注释（&#x2F;**&#x2F;）或 Markdown 文档时，它又会贴心地自动切换为中文输入法，而且完美兼容中英文混合输入场景，让注释撰写无比流畅。以编写 Javadoc 为例，中文描述与英文代码符号能在它的帮助下无缝衔接，你可以专注于内容表达，无需再为输入法切换分神 。</p>
<p>除了上述区域，在工具窗口与特殊场景中，它也能发挥作用。比如在 Git 提交框，当你输入 Commit Message 时，它自动切为中文，方便你规范地撰写中文提交说明；在终端（Terminal）&#x2F;Project 窗口，它会强制英文输入，避免命令行中混入中文字符，保证命令执行顺畅；如果你使用 IdeaVim 模式，在 NORMAL 模式它自动切换为英文，INSERT 模式则按当前编辑场景智能切换，让 Vim 操作与输入法切换配合默契 。</p>
<h3 id="2-可视化状态反馈：光标即输入状态指示器"><a href="#2-可视化状态反馈：光标即输入状态指示器" class="headerlink" title="2 可视化状态反馈：光标即输入状态指示器"></a>2 可视化状态反馈：光标即输入状态指示器</h3><p>为了让你随时了解当前的输入状态，Smart Input Pro 还提供了可视化状态反馈功能。</p>
<p>其中，三色光标提示十分直观，蓝色光标代表英文小写，紫色光标表示英文大写，红色光标则意味着中文输入 。在编码过程中，你无需将视线移至系统状态栏，只要看一眼光标颜色，就能快速确认输入状态，大大减少了误操作的概率。比如，当你看到红色光标时，就知道当前是中文输入法状态，可以放心输入中文内容；而看到蓝色光标，就明白现在适合输入英文代码 。</p>
<p>此外，还有轻量浮动标签，它会在光标附近显示 “EN” 或 “中文” 微型标签，这个标签支持自定义位置与透明度。你可以根据自己的习惯，将它调整到既不遮挡视线，又能轻松看到的位置，还能根据个人喜好设置透明度，兼顾提示性与无干扰性，让你在编码时随时掌握输入状态 。</p>
<h3 id="3-高度可定制化：打造个人专属输入规则"><a href="#3-高度可定制化：打造个人专属输入规则" class="headerlink" title="3 高度可定制化：打造个人专属输入规则"></a>3 高度可定制化：打造个人专属输入规则</h3><p>每个人的编码习惯和项目需求都有所不同，Smart Input Pro 充分考虑到这一点，提供了高度可定制化的功能。</p>
<p>通过自定义正则匹配，你可以轻松定义特殊场景。例如，针对 i18n 相关文件（*.zh-CN.vue），你可以通过正则表达式让插件强制中文输入，确保国际化文件中的中文内容输入顺畅；或者在 SQL 脚本中，识别中文注释块并自动切为中文，满足特定的编程需求 。只需要简单编写正则表达式，就能让插件按照你的想法工作 。</p>
<p>它还有强大的输入法记忆机制。当你手动切换输入法后，插件会自动学习你的习惯。比如，在特定文件类型中，你偏好某种输入状态，它就会记住这个习惯，逐步优化切换策略，随着使用时间的增加，它会越来越 “懂你” ，让输入法的切换更加贴合你的使用习惯，为你打造个性化的编码输入环境 。</p>
<h2 id="使用指南：三步开启智能输入之旅"><a href="#使用指南：三步开启智能输入之旅" class="headerlink" title="使用指南：三步开启智能输入之旅"></a>使用指南：三步开启智能输入之旅</h2><h3 id="1-快速安装与初始化"><a href="#1-快速安装与初始化" class="headerlink" title="1 快速安装与初始化"></a>1 快速安装与初始化</h3><p>安装 Smart Input Pro 的过程非常简单，无论你是在线安装还是离线安装，都能轻松完成。</p>
<p>如果你选择在线安装，在 IDE 内打开插件市场，这就好比是一个插件的大超市，里面摆满了各种各样的插件 。在搜索框中输入 “Smart Input Pro”，就像在超市里寻找特定的商品一样，很快就能找到它。找到后，点击安装按钮，插件就会自动下载并安装到你的 IDE 中。安装完成后，按照提示重启 IDE，整个过程无需手动配置，就像拿到一个新的电子产品，打开就能用，真正做到了开箱即用 。</p>
<p>要是你处于网络受限的环境，也不用担心，还可以选择离线安装。你可以从 JetBrains 插件市场下载对应版本的 ZIP 文件，这个文件就像是一个装满插件的包裹 。下载好后，通过 “Install Plugin from Disk”（从磁盘安装插件）选项将下载的 ZIP 文件导入到 IDE 中，就像把包裹里的东西放进你的电脑里一样简单，轻松解决网络问题带来的困扰 。</p>
<h3 id="2-基础配置优化"><a href="#2-基础配置优化" class="headerlink" title="2 基础配置优化"></a>2 基础配置优化</h3><p>安装完成后，还需要进行一些基础配置，让插件更好地适应你的使用习惯 。</p>
<p>首先是选择默认中文输入法，在插件设置中，你可以指定自己常用的中文输入法，比如大家常用的搜狗输入法、百度输入法等 。这就像是给插件设定一个语言助手，让它知道你平时喜欢用哪种中文输入法，这样它就能在需要的时候精准地帮你切换，确保输入法的切换符合你的习惯 。</p>
<p>对于不同系统的用户，它还有一些专属的跨平台适配设置。Windows 用户可以启用 “离开 IDE 恢复系统输入法” 功能，当你离开 IDE 去做其他事情，再回到 IDE 时，输入法会自动恢复到你离开前在 IDE 中的设置，就像 IDE 记住了你离开时的输入法状态一样 。而 Mac 用户则更方便，插件支持全局输入法状态记忆，当你在不同应用之间切换时，它会自动还原你的输入环境，比如你从 IDE 切换到浏览器，再切回 IDE，输入法还是你在 IDE 中使用时的状态，让你的输入体验更加流畅 。</p>
<h3 id="3-进阶设置：释放插件潜力"><a href="#3-进阶设置：释放插件潜力" class="headerlink" title="3 进阶设置：释放插件潜力"></a>3 进阶设置：释放插件潜力</h3><p>如果你想要进一步发挥插件的强大功能，还可以进行进阶设置 。</p>
<p>通过自定义场景规则，你可以打造适合自己的输入逻辑。进入 “Settings&gt; Smart Input Pro &gt; Custom Rules”（设置 &gt; Smart Input Pro &gt; 自定义规则），在这里，你可以针对特定的文件路径、代码块结构添加专属的切换逻辑 。比如，在一个 Vue 项目中，你希望 Vue 模板中的中文文案区域始终保持中文输入，就可以在这里进行设置。通过编写规则，让插件识别 Vue 模板文件，当光标进入中文文案区域时，自动切换并保持中文输入法状态，让你的代码编写更加高效 。</p>
<p>对于使用低配设备的开发者，为了平衡智能度与流畅度，还可以开启 “轻量模式” 。开启后，插件会降低资源占用，就像给插件 “瘦身” 一样，让它在低配设备上也能轻松运行，不会因为占用过多资源而导致设备卡顿，让你在享受智能输入的同时，也能保证设备的流畅运行 。</p>
<h2 id="实战案例：从低效切换到丝滑编码"><a href="#实战案例：从低效切换到丝滑编码" class="headerlink" title="实战案例：从低效切换到丝滑编码"></a>实战案例：从低效切换到丝滑编码</h2><h3 id="1-典型开发场景对比"><a href="#1-典型开发场景对比" class="headerlink" title="1 典型开发场景对比"></a>1 典型开发场景对比</h3><p>为了让大家更直观地感受到 Smart Input Pro 带来的效率提升，我们来看一下实际开发场景中使用插件前后的对比 。</p>
<p>在未使用插件之前，开发过程中充满了各种因输入法切换带来的困扰。就拿编写代码来说，平均每 5 分钟，我就会因为输入法的问题而出现 1 次输入状态错误。比如在定义变量名时，本应使用英文输入法输入字母，却因为疏忽还停留在中文输入法状态，结果输入了全角字符，导致代码出现语法错误 。在添加注释时，也经常会因为没有及时切换输入法，使得注释中混入英文符号，或者在代码中出现中文标点，这不仅影响了代码的可读性，还需要花费额外的时间去反复检查修正 。</p>
<p>而使用 Smart Input Pro 插件后，情况就大不一样了 。在代码区，它会自动切换为英文输入法，确保我输入的代码准确无误；在注释区，又会自动切换为中文输入法，让我可以流畅地撰写注释 。就连在 Git 提交时，也无需手动切换输入法，直接就能用中文输入提交信息 。根据我的统计，使用插件后，日均减少了 200 + 次无效切换操作，编码时的专注度也提升了 30% ，真正实现了从低效到高效的转变 。</p>
<h3 id="2-具体操作演示（以-Vue-开发为例）"><a href="#2-具体操作演示（以-Vue-开发为例）" class="headerlink" title="2 具体操作演示（以 Vue 开发为例）"></a>2 具体操作演示（以 Vue 开发为例）</h3><p>接下来，以 Vue 开发为例，为大家详细演示一下 Smart Input Pro 插件的具体使用过程 。</p>
<p>在<code>&lt;template&gt;</code>标签内编写代码时，当我输入<code>v-model</code>，准备补全变量名，此时插件会保持英文输入法状态，让我可以毫无干扰地输入英文变量名 。比如输入<code>v-model=&quot;userName&quot;</code> ，整个输入过程非常流畅，不用担心输入法的问题 。</p>
<p>当切换到<code>&lt;script&gt;</code>的注释区域，我输入<code>// 按钮点击事件</code> ，插件会自动切换为中文输入法，我可以直接输入中文描述，快速完成注释内容的编写 。像<code>// 点击按钮后，调用接口获取数据</code> ，轻松就能完成输入 。</p>
<p>当打开 Git 提交窗口，准备输入提交信息时，比如输入 “修复表单验证逻辑” ，此时无需手动切换输入法，因为插件已经自动将输入法切换为中文，直接输入即可，大大提高了提交效率 。</p>
<p>进入终端输入<code>npm run dev</code>时，插件会强制将输入法切换为英文，避免因为误输入中文而导致命令错误 。即使我不小心按下了中文输入法快捷键，插件也能迅速调整回来，确保命令的正确执行 。</p>
<h2 id="优缺点分析：客观评估插件价值"><a href="#优缺点分析：客观评估插件价值" class="headerlink" title="优缺点分析：客观评估插件价值"></a>优缺点分析：客观评估插件价值</h2><h3 id="1-核心优势"><a href="#1-核心优势" class="headerlink" title="1 核心优势"></a>1 核心优势</h3><ul>
<li><p><strong>效率提升显著</strong>：在日常开发中，我们常常会因为频繁切换输入法而打断思路，降低编码效率 。而 Smart Input Pro 的自动切换功能十分强大，它能够覆盖 90% 以上的常规场景，让我们无需手动切换输入法，从而将更多的时间和精力投入到代码的编写中。以我个人的使用体验为例，在使用该插件之前，我每天需要花费大量的时间在输入法切换上，而使用之后，这些时间被节省了下来，我可以更加专注地思考代码逻辑，编码效率得到了大幅提升 。</p>
</li>
<li><p><strong>错误预防能力</strong>：在代码编写过程中，因符号错误导致的编译问题是我们经常会遇到的困扰 。而 Smart Input Pro 通过场景化输入法控制，能够有效地避免这类问题的发生。它会在我们输入代码时，自动切换为英文输入法，确保我们输入的符号都是正确的；而在输入注释时，又会自动切换为中文输入法，方便我们撰写注释 。根据实际使用情况统计，使用该插件后，因符号错误导致的编译问题降低了 80%+，大大提高了代码的质量和开发效率 。</p>
</li>
<li><p><strong>学习成本极低</strong>：对于开发者来说，学习新工具的成本是一个重要的考虑因素 。而 Smart Input Pro 的默认配置即满足多数需求，即使是初次使用的用户，也能快速上手。对于一些进阶功能，它还提供了图形化界面操作，我们只需要通过简单的设置，就能轻松实现个性化的需求，无需编写复杂的规则 。这使得我们能够在短时间内熟练掌握插件的使用方法，快速提升编码效率 。</p>
</li>
</ul>
<h3 id="2-改进空间"><a href="#2-改进空间" class="headerlink" title="2 改进空间"></a>2 改进空间</h3><ul>
<li><p><strong>硬件兼容性</strong>：在配置较低的电脑上，当我们处理复杂项目时，Smart Input Pro 可能会出现轻微光标延迟的情况 。这是因为插件在运行过程中需要占用一定的系统资源，而配置较低的电脑可能无法满足其需求 。不过，我们可以通过开启轻量模式来缓解这一问题。轻量模式下，插件会降低对系统资源的占用，从而提高运行的流畅度 。虽然开启轻量模式后，插件的一些智能功能可能会受到一定影响，但对于配置较低的电脑用户来说，这仍然是一个不错的解决方案 。</p>
</li>
<li><p><strong>高级功能付费</strong>：Smart Input Pro 的高级功能，如自定义正则匹配、多设备同步等，需要订阅专业版才能使用 。对于一些对功能要求较高的用户来说，这可能会增加一定的使用成本 。专业版的月费约 10 元，虽然价格不算高，但对于一些个人开发者或小型团队来说，可能还是会有些犹豫 。不过，免费版已经包含了核心切换功能，能够满足大多数用户的日常需求 。如果用户对高级功能的需求不是很迫切，那么使用免费版也完全可以 。</p>
</li>
</ul>
<h2 id="总结与推荐：谁该拥有这款神器？"><a href="#总结与推荐：谁该拥有这款神器？" class="headerlink" title="总结与推荐：谁该拥有这款神器？"></a>总结与推荐：谁该拥有这款神器？</h2><h3 id="1-适合人群"><a href="#1-适合人群" class="headerlink" title="1 适合人群"></a>1 适合人群</h3><ul>
<li><p><strong>中文开发者</strong>：如果你是一位中文开发者，日常开发中需要频繁在代码与中文注释、文档间切换，那么 Smart Input Pro 绝对是你的得力助手。它能自动识别输入场景，在代码区自动切换为英文输入法，在注释和文档区自动切换为中文输入法，让你无需手动切换，专注于代码的编写和逻辑的实现 。尤其是对于 Java、前端、全栈等领域的开发者，这款插件的实用性更强，能够有效提高你的开发效率 。</p>
</li>
<li><p><strong>效率敏感型开发者</strong>：对于那些追求高效开发，希望减少重复性操作，将更多精力聚焦于逻辑实现而非工具切换的人群来说，Smart Input Pro 无疑是一个绝佳的选择 。它的自动切换功能能够极大地减少无效操作，让你在编码过程中保持流畅的思路，将更多的时间和精力投入到真正有价值的工作中 。</p>
</li>
<li><p><strong>Vim&#x2F;Emacs 用户</strong>：如果你是 Vim&#x2F;Emacs 用户，在使用 IDEA 等开发工具时，常常被 IDE 快捷键与输入法切换间的频繁冲突所困扰，那么 Smart Input Pro 可以完美解决你的问题 。它能够与 IdeaVim 等模式完美适配，在 NORMAL 模式下自动切换英文，确保命令正确执行；在 INSERT 模式下则按当前编辑场景智能切换，让你的 Vim 操作与输入法切换配合得更加默契 。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/10/%E6%89%8B%E6%8A%8A%E6%89%8B%E9%85%8D%E7%BD%AE-PhpStorm-WSL2%EF%BC%88Alpine-Linux%EF%BC%89-XDebug-%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="l1n6yun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="l1n6yun's Blog">
      <meta itemprop="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | l1n6yun's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/10/%E6%89%8B%E6%8A%8A%E6%89%8B%E9%85%8D%E7%BD%AE-PhpStorm-WSL2%EF%BC%88Alpine-Linux%EF%BC%89-XDebug-%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">手把手配置 PhpStorm + WSL2（Alpine Linux）+ XDebug 调试环境</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-10 11:25:53" itemprop="dateCreated datePublished" datetime="2025-10-10T11:25:53+08:00">2025-10-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 Windows 11 下使用 WSL2 开发 PHP 项目时，断点调试是提升效率的关键。本文将详细讲解如何基于 <strong>Alpine Linux v3.18</strong> 配置 PhpStorm + XDebug 环境，解决版本兼容、路径映射、调试连接等核心问题，适用于 Hyperf、Laravel 等主流 PHP 框架。</p>
<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>先明确本地开发环境的核心信息，避免后续配置因版本不匹配导致失败：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>版本&#x2F;信息</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>宿主机系统</td>
<td>Windows 11</td>
<td>需已启用 WSL2（需先开启虚拟机平台功能）</td>
</tr>
<tr>
<td>WSL2 发行版</td>
<td>Alpine Linux v3.18</td>
<td>已更换阿里云源（安装速度更快）</td>
</tr>
<tr>
<td>PHP 版本</td>
<td>8.1.2</td>
<td>需与 XDebug 版本兼容</td>
</tr>
<tr>
<td>XDebug 版本</td>
<td>3.2.2</td>
<td>对应 PHP 8.1 的 PECL 包</td>
</tr>
<tr>
<td>调试框架示例</td>
<td>Hyperf 3.x</td>
<td>也适用于 Laravel、ThinkPHP 等</td>
</tr>
<tr>
<td>PhpStorm 版本</td>
<td>2023.x 及以上</td>
<td>确保支持 XDebug 3.x</td>
</tr>
</tbody></table>
<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>在开始配置前，需完成以下基础操作：</p>
<ol>
<li><strong>启用 WSL2 并安装 Alpine</strong>：参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL3dpbmRvd3Mvd3NsL2luc3RhbGw=">微软官方文档<i class="fa fa-external-link-alt"></i></span>，确保 Alpine 能正常通过 <code>wsl</code> 命令启动。</li>
<li><strong>更换 Alpine 国内源</strong>：默认源速度较慢，需先替换为阿里云源（否则后续安装 XDebug 可能失败）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑源配置文件</span></span><br><span class="line">vi /etc/apk/repositories</span><br><span class="line"><span class="comment"># 替换为阿里云源（Alpine 3.18）</span></span><br><span class="line">https://mirrors.aliyun.com/alpine/v3.18/main</span><br><span class="line">https://mirrors.aliyun.com/alpine/v3.18/community</span><br><span class="line"><span class="comment"># 更新源缓存</span></span><br><span class="line">apk update</span><br></pre></td></tr></table></figure></li>
<li><strong>确认 PHP 已安装</strong>：在 WSL 中执行 <code>php -v</code>，确保输出 <code>PHP 8.1.2</code> 信息（若未安装，需先通过 <code>apk add php81 php81-cli php81-common</code> 安装）。</li>
</ol>
<h2 id="步骤-1：安装-XDebug（WSL-内操作）"><a href="#步骤-1：安装-XDebug（WSL-内操作）" class="headerlink" title="步骤 1：安装 XDebug（WSL 内操作）"></a>步骤 1：安装 XDebug（WSL 内操作）</h2><p>XDebug 需通过 Alpine 的 PECL 仓库安装，且必须选择与 PHP 版本匹配的包（PHP 8.1 对应 <code>php81-pecl-xdebug</code>）。</p>
<h3 id="1-搜索匹配的-XDebug-包"><a href="#1-搜索匹配的-XDebug-包" class="headerlink" title="1 搜索匹配的 XDebug 包"></a>1 搜索匹配的 XDebug 包</h3><p>先确认仓库中是否有对应 PHP 版本的 XDebug：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apk search xdebug</span><br></pre></td></tr></table></figure>
<p>输出结果中需包含 <code>php81-pecl-xdebug-3.2.2-r0</code>（若显示 <code>php82-*</code> 则为 PHP 8.2 版本，请勿安装，避免版本不兼容）。</p>
<h3 id="2-安装-XDebug"><a href="#2-安装-XDebug" class="headerlink" title="2 安装 XDebug"></a>2 安装 XDebug</h3><p>执行安装命令，Alpine 会自动处理依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apk add php81-pecl-xdebug</span><br></pre></td></tr></table></figure>
<p>安装成功后，执行以下命令验证是否加载 XDebug 扩展：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -v</span><br></pre></td></tr></table></figure>
<p>若输出中包含 <code>with Xdebug v3.2.2</code>，说明安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PHP 8.1.2 (cli) (built: Feb  1 2023 12:05:42) (NTS)</span><br><span class="line">Copyright (c) The PHP Group</span><br><span class="line">Zend Engine v4.1.2, Copyright (c) Zend Technologies</span><br><span class="line">    with Xdebug v3.2.2, Copyright (c) 2002-2023, by Derick Rethans</span><br></pre></td></tr></table></figure>


<h2 id="步骤-2：配置-XDebug（关键！避免调试失败）"><a href="#步骤-2：配置-XDebug（关键！避免调试失败）" class="headerlink" title="步骤 2：配置 XDebug（关键！避免调试失败）"></a>步骤 2：配置 XDebug（关键！避免调试失败）</h2><p>XDebug 3.x 与 2.x 配置差异较大，需编辑专属配置文件，核心是指定「调试模式」「宿主机地址」「端口」。</p>
<h3 id="1-找到-XDebug-配置文件"><a href="#1-找到-XDebug-配置文件" class="headerlink" title="1 找到 XDebug 配置文件"></a>1 找到 XDebug 配置文件</h3><p>Alpine 中 PHP 8.1 的 XDebug 配置文件路径固定为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/php81/conf.d/50_xdebug.ini</span><br></pre></td></tr></table></figure>

<h3 id="2-写入配置内容"><a href="#2-写入配置内容" class="headerlink" title="2 写入配置内容"></a>2 写入配置内容</h3><p>将以下内容复制到文件中，<strong>每个配置项都有详细注释</strong>，无需额外修改（<code>host.docker.internal</code> 是 WSL2 内置的「宿主机 IP 别名」，无需手动查宿主机 IP）：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 启用 XDebug 扩展（必须放在最前面）</span></span><br><span class="line"><span class="attr">zend_extension</span>=xdebug.so</span><br><span class="line"></span><br><span class="line"><span class="comment">; 调试模式：debug（断点调试）+ develop（开发辅助，如错误提示）</span></span><br><span class="line"><span class="attr">xdebug.mode</span>=debug,develop</span><br><span class="line"></span><br><span class="line"><span class="comment">; 自动发现客户端主机（WSL 环境下建议开启，避免手动改 IP）</span></span><br><span class="line"><span class="attr">xdebug.discover_client_host</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 强制指定宿主机地址（WSL2 专用，指向 Windows 宿主机）</span></span><br><span class="line"><span class="attr">xdebug.client_host</span>=host.docker.internal</span><br><span class="line"></span><br><span class="line"><span class="comment">; 调试端口（默认 9003，需与 PhpStorm 保持一致，避免冲突）</span></span><br><span class="line"><span class="attr">xdebug.client_port</span>=<span class="number">9003</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; IDE 标识（必须与 PhpStorm 配置的 IDE Key 一致，默认 PHPSTORM）</span></span><br><span class="line"><span class="attr">xdebug.idekey</span>=PHPSTORM</span><br><span class="line"></span><br><span class="line"><span class="comment">; 请求启动时自动触发调试（无需手动触发，开发更便捷）</span></span><br><span class="line"><span class="attr">xdebug.start_with_request</span>=<span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 显示详细调试日志（调试失败时可开启，日志路径自行指定）</span></span><br><span class="line"><span class="comment">; xdebug.log=/var/log/xdebug.log</span></span><br></pre></td></tr></table></figure>

<h3 id="3-验证配置生效"><a href="#3-验证配置生效" class="headerlink" title="3 验证配置生效"></a>3 验证配置生效</h3><p>配置后需重启 PHP 服务（若用 Hyperf 等框架，重启服务即可），并执行以下命令确认配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -i | grep XDebug</span><br></pre></td></tr></table></figure>
<p>输出中需包含 <code>xdebug.mode =&gt; debug,develop</code> <code>xdebug.client_port =&gt; 9003</code> 等信息，说明配置正确。</p>
<h2 id="步骤-3：添加环境变量（关联-PhpStorm-服务器）"><a href="#步骤-3：添加环境变量（关联-PhpStorm-服务器）" class="headerlink" title="步骤 3：添加环境变量（关联 PhpStorm 服务器）"></a>步骤 3：添加环境变量（关联 PhpStorm 服务器）</h2><p>需在 WSL 中设置 <code>PHP_IDE_CONFIG</code> 环境变量，指定 PhpStorm 中配置的「服务器名称」，确保路径映射生效。</p>
<h3 id="1-写入环境变量"><a href="#1-写入环境变量" class="headerlink" title="1 写入环境变量"></a>1 写入环境变量</h3><p>执行以下命令，将环境变量添加到 <code>~/.bashrc</code>（若用 Zsh 则改为 <code>~/.zshrc</code>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入环境变量（SomeName 可自定义，后续 PhpStorm 需用相同名称）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PHP_IDE_CONFIG=&quot;serverName=SomeName&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立即生效环境变量（无需重启 WSL）</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="2-验证环境变量"><a href="#2-验证环境变量" class="headerlink" title="2 验证环境变量"></a>2 验证环境变量</h3><p>执行 <code>echo $PHP_IDE_CONFIG</code>，输出 <code>serverName=SomeName</code> 即成功。</p>
<h2 id="步骤-4：配置-PhpStorm（宿主机操作）"><a href="#步骤-4：配置-PhpStorm（宿主机操作）" class="headerlink" title="步骤 4：配置 PhpStorm（宿主机操作）"></a>步骤 4：配置 PhpStorm（宿主机操作）</h2><p>PhpStorm 需配置「PHP 解释器」「服务器」「XDebug 端口」，核心是解决「WSL 路径与 Windows 路径映射」问题（断点不命中的常见原因）。</p>
<h3 id="1-配置-PHP-解释器（关联-WSL-中的-PHP）"><a href="#1-配置-PHP-解释器（关联-WSL-中的-PHP）" class="headerlink" title="1 配置 PHP 解释器（关联 WSL 中的 PHP）"></a>1 配置 PHP 解释器（关联 WSL 中的 PHP）</h3><ol>
<li>打开 PhpStorm → 进入 <code>File &gt; Settings &gt; PHP</code>（Windows&#x2F;Linux）或 <code>PhpStorm &gt; Settings &gt; PHP</code>（Mac）。</li>
<li>点击「CLI Interpreter」右侧的 <code>...</code> → 点击左上角 <code>+</code> → 选择「From Docker, Vagrant, WSL, Remote…」。</li>
<li>在弹出的窗口中选择「WSL」→ 选择已安装的「Alpine Linux」→ 自动识别 PHP 路径（通常为 <code>/usr/bin/php81</code>）→ 点击「OK」。</li>
<li>回到 PHP 配置页，确保「CLI Interpreter」已选中 WSL 中的 PHP 8.1。</li>
</ol>
<h3 id="2-配置服务器（路径映射关键）"><a href="#2-配置服务器（路径映射关键）" class="headerlink" title="2 配置服务器（路径映射关键）"></a>2 配置服务器（路径映射关键）</h3><ol>
<li>进入 <code>File &gt; Settings &gt; PHP &gt; Servers</code> → 点击左上角 <code>+</code>，配置以下信息：<ul>
<li><strong>Name</strong>：输入 <code>SomeName</code>（必须与 WSL 中 <code>serverName</code> 一致！）。</li>
<li><strong>Host</strong>：输入项目的访问地址（如 Hyperf 项目默认 <code>127.0.0.1</code>，Laravel 项目可能为 <code>localhost</code>）。</li>
<li><strong>Port</strong>：输入项目端口（如 Hyperf 默认 <code>9501</code>，Laravel 默认 <code>8000</code>）。</li>
<li><strong>Debugger</strong>：选择 <code>XDebug</code>。</li>
<li><strong>Use path mappings</strong>：必须勾选！然后配置「本地路径 ↔ WSL 路径」：<ul>
<li>左侧「Local Path」：选择 Windows 中项目的本地路径（如 <code>D:\projects\hyperf-demo</code>）。</li>
<li>右侧「Remote Path」：选择 WSL 中项目的路径（如 <code>/home/user/hyperf-demo</code>）。</li>
</ul>
</li>
</ul>
</li>
<li>点击「OK」保存。</li>
</ol>
<h3 id="3-配置-XDebug-端口"><a href="#3-配置-XDebug-端口" class="headerlink" title="3 配置 XDebug 端口"></a>3 配置 XDebug 端口</h3><ol>
<li>进入 <code>File &gt; Settings &gt; PHP &gt; Debug &gt; XDebug</code>。</li>
<li>确认「Debug port」为 <code>9003</code>（与 WSL 中 <code>xdebug.client_port</code> 一致）。</li>
<li>勾选「Allow connection to unprofiled scripts」→ 点击「OK」。</li>
</ol>
<h2 id="步骤-5：启动调试侦听（PhpStorm-操作）"><a href="#步骤-5：启动调试侦听（PhpStorm-操作）" class="headerlink" title="步骤 5：启动调试侦听（PhpStorm 操作）"></a>步骤 5：启动调试侦听（PhpStorm 操作）</h2><p>PhpStorm 需要主动「侦听」WSL 发送的调试请求，步骤如下：</p>
<ol>
<li>点击 PhpStorm 右上角的「电话」图标（Hover 显示「Start Listening for PHP Debug Connections」），图标变亮表示已启动侦听。</li>
<li>（可选）开启「断点自动触发」：点击「小虫子」图标（Hover 显示「Debug ‘当前项目名’」），或按快捷键 <code>Shift + F9</code>。</li>
</ol>
<h3 id="验证侦听是否成功"><a href="#验证侦听是否成功" class="headerlink" title="验证侦听是否成功"></a>验证侦听是否成功</h3><p>在 Windows 中打开「命令提示符（CMD）」，执行以下命令查看 9003 端口是否被 PhpStorm 占用：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | <span class="built_in">findstr</span> <span class="number">9003</span></span><br></pre></td></tr></table></figure>
<p>若输出以下内容（<code>LISTENING</code> 状态），说明侦听正常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP    0.0.0.0:9003           0.0.0.0:0              LISTENING       31268  # 31268 是 PhpStorm 进程 ID</span><br><span class="line">TCP    [::]:9003              [::]:0                 LISTENING       31268</span><br></pre></td></tr></table></figure>


<h2 id="步骤-6：启动项目并验证调试连接"><a href="#步骤-6：启动项目并验证调试连接" class="headerlink" title="步骤 6：启动项目并验证调试连接"></a>步骤 6：启动项目并验证调试连接</h2><p>以 Hyperf 项目为例，在 WSL 中启动项目，然后验证 PhpStorm 与 WSL 的连接。</p>
<h3 id="1-启动-PHP-项目（WSL-内）"><a href="#1-启动-PHP-项目（WSL-内）" class="headerlink" title="1 启动 PHP 项目（WSL 内）"></a>1 启动 PHP 项目（WSL 内）</h3><p>进入项目根目录，执行启动命令（不同框架命令不同）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hyperf 项目启动命令</span></span><br><span class="line">php bin/hyperf.php start</span><br></pre></td></tr></table></figure>
<p>启动成功后输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Worker#0 started.</span><br><span class="line">[INFO] HTTP Server listening at 0.0.0.0:9501</span><br></pre></td></tr></table></figure>

<h3 id="2-验证调试连接（Windows-CMD）"><a href="#2-验证调试连接（Windows-CMD）" class="headerlink" title="2 验证调试连接（Windows CMD）"></a>2 验证调试连接（Windows CMD）</h3><p>再次执行端口监听命令，查看是否出现「ESTABLISHED」状态（表示 WSL 与 PhpStorm 已建立连接）：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | <span class="built_in">findstr</span> <span class="number">9003</span></span><br></pre></td></tr></table></figure>
<p>成功连接的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP    0.0.0.0:9003           0.0.0.0:0              LISTENING       31268</span><br><span class="line">TCP    172.23.240.1:9003      172.23.252.48:43416    ESTABLISHED     31268  # 新增的连接</span><br><span class="line">TCP    [::]:9003              [::]:0                 LISTENING       31268</span><br></pre></td></tr></table></figure>


<h2 id="步骤-7：断点调试（核心操作）"><a href="#步骤-7：断点调试（核心操作）" class="headerlink" title="步骤 7：断点调试（核心操作）"></a>步骤 7：断点调试（核心操作）</h2><p>连接成功后，即可通过断点调试查看变量、调用栈等信息，以 Hyperf 控制器为例：</p>
<ol>
<li><strong>打断点</strong>：在 PhpStorm 中打开 <code>app/Controller/IndexController.php</code>，在 <code>index</code> 方法的第一行代码左侧点击，出现红色圆点（断点）。</li>
<li><strong>触发请求</strong>：在 Windows 浏览器中访问 <code>http://127.0.0.1:9501</code>（Hyperf 默认接口），或用 Postman 发送请求。</li>
<li><strong>查看调试面板</strong>：请求触发后，PhpStorm 会自动弹出调试面板，包含以下核心信息：<ul>
<li><strong>Frames</strong>：查看函数调用栈。</li>
<li><strong>Variables</strong>：查看当前作用域的变量值（如请求参数、数据库查询结果）。</li>
<li><strong>Watches</strong>：手动添加需要监控的变量。</li>
</ul>
</li>
<li><strong>调试控制</strong>：使用 PhpStorm 底部的调试工具栏控制流程：<ul>
<li><code>F8</code>：单步执行（跳过函数内部）。</li>
<li><code>F7</code>：单步进入（进入函数内部）。</li>
<li><code>Shift + F8</code>：单步跳出（从函数内部跳出）。</li>
<li><code>F9</code>：继续执行（直到下一个断点）。</li>
</ul>
</li>
</ol>
<h2 id="常见问题排查（避坑指南）"><a href="#常见问题排查（避坑指南）" class="headerlink" title="常见问题排查（避坑指南）"></a>常见问题排查（避坑指南）</h2><h3 id="断点不命中？"><a href="#断点不命中？" class="headerlink" title="断点不命中？"></a>断点不命中？</h3><ul>
<li>原因 1：路径映射错误 → 检查 PhpStorm 服务器配置中的「Local Path」与「Remote Path」是否完全对应（如 Windows 路径带 <code>\</code>，WSL 路径带 <code>/</code>）。</li>
<li>原因 2：XDebug 配置错误 → 执行 <code>php -i | grep XDebug</code>，确认 <code>xdebug.mode</code> 包含 <code>debug</code>，<code>xdebug.client_host</code> 为 <code>host.docker.internal</code>。</li>
<li>原因 3：端口被占用 → 用 <code>netstat -ano | findstr 9003</code> 查看是否有其他进程占用 9003 端口，若有则修改 <code>xdebug.client_port</code> 为其他端口（如 9004），并同步更新 PhpStorm 配置。</li>
</ul>
<h3 id="无法连接到-XDebug？"><a href="#无法连接到-XDebug？" class="headerlink" title="无法连接到 XDebug？"></a>无法连接到 XDebug？</h3><ul>
<li>原因 1：PhpStorm 未启动侦听 → 确认右上角「电话」图标已亮。</li>
<li>原因 2：WSL 网络问题 → 尝试手动指定宿主机 IP（替换 <code>xdebug.client_host</code> 为 Windows 的局域网 IP，如 <code>192.168.1.100</code>）。</li>
<li>原因 3：XDebug 日志未开启 → 开启 <code>xdebug.log=/var/log/xdebug.log</code>，查看日志中的错误信息（如 <code>Could not connect to client host</code>）。</li>
</ul>
<h3 id="PHP-版本与-XDebug-不兼容？"><a href="#PHP-版本与-XDebug-不兼容？" class="headerlink" title="PHP 版本与 XDebug 不兼容？"></a>PHP 版本与 XDebug 不兼容？</h3><ul>
<li>症状：执行 <code>php -v</code> 不显示 XDebug 信息 → 确保安装的 XDebug 包与 PHP 版本匹配（PHP 8.1 对应 <code>php81-pecl-xdebug</code>，PHP 8.2 对应 <code>php82-pecl-xdebug</code>）。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上步骤，即可在 Windows 11 + WSL2（Alpine）环境下实现 PhpStorm 与 XDebug 的无缝调试。核心是「版本匹配」「路径映射」「端口一致」三个关键点，遇到问题时优先查看 XDebug 日志和端口监听状态，大部分问题可快速定位解决。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/%E5%85%B3%E9%97%ADSuperfetch%E6%9C%8D%E5%8A%A1%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9A%84%E5%8F%8C%E5%88%83%E5%89%91%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="l1n6yun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="l1n6yun's Blog">
      <meta itemprop="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | l1n6yun's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/24/%E5%85%B3%E9%97%ADSuperfetch%E6%9C%8D%E5%8A%A1%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9A%84%E5%8F%8C%E5%88%83%E5%89%91%EF%BC%9F/" class="post-title-link" itemprop="url">关闭Superfetch服务：系统性能的双刃剑？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-24 14:17:52" itemprop="dateCreated datePublished" datetime="2025-07-24T14:17:52+08:00">2025-07-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Superfetch-服务是什么"><a href="#Superfetch-服务是什么" class="headerlink" title="Superfetch 服务是什么"></a>Superfetch 服务是什么</h2><p>Superfetch，直译为 “超级预取” ，是 Windows 系统中的一项智能服务，最早在 Windows Vista 系统中引入，后续的 Windows 7、Windows 8 以及 Windows 10 等系统版本也都沿用了这一功能，其核心作用在于提升系统和应用程序的运行速度。</p>
<p>它的运行原理基于对用户使用习惯的深度学习与分析。当我们日常使用电脑时，Superfetch 会在后台默默监控我们频繁开启的各类程序。一旦它 “熟悉” 了我们的使用模式，就会将这些常用程序运行时所依赖的数据和代码，提前加载到内存之中。就好比你每天早上出门前，会提前把当天要用的文件准备好放在包里，等真正需要的时候，就能迅速拿出来使用，无需再临时翻找。</p>
<p>举个简单的例子，假如你每天上班打开电脑后的第一件事就是启动微信与同事沟通工作，那么 Superfetch 服务就会 “记住” 这个习惯。在你下次开机时，它会提前将微信运行所需的关键文件和数据从硬盘读取到内存里。这样一来，当你点击微信图标时，程序便能从内存中快速获取所需内容，实现几乎瞬间启动，大大节省了等待时间，让你的工作衔接更加顺畅高效。又或者你经常使用 Photoshop 处理图片，Superfetch 也会将 Photoshop 运行时可能用到的图像算法库、常用滤镜数据等提前加载，使得你在启动 Photoshop 以及使用各种功能时，响应速度明显加快，创作过程更加流畅。</p>
<p>不过，Superfetch 在发挥作用的过程中，也会对系统资源产生一定的占用。它需要消耗一定的 CPU 运算资源来分析用户行为模式，同时还会占用一部分内存空间用于存放预读取的数据，这也是我们在考虑是否禁用它时需要权衡的因素。</p>
<h2 id="为什么有人想禁用-Superfetch-服务"><a href="#为什么有人想禁用-Superfetch-服务" class="headerlink" title="为什么有人想禁用 Superfetch 服务"></a>为什么有人想禁用 Superfetch 服务</h2><p>尽管 Superfetch 服务出发点是好的，旨在提升系统性能，但在实际使用中，不少用户却萌生出禁用它的想法，这背后有着多方面的原因。</p>
<h3 id="占用过多系统资源"><a href="#占用过多系统资源" class="headerlink" title="占用过多系统资源"></a>占用过多系统资源</h3><p>Superfetch 服务在运行过程中，对系统资源有着较高的需求。它需要持续分析用户的使用习惯，这一过程会占用一定的 CPU 资源，尤其是在系统刚刚启动或者用户使用习惯发生较大变化时，CPU 的占用率会明显上升，导致电脑在这段时间内反应迟缓，打开其他程序时也会出现卡顿现象。比如，当你早上开机后，想要快速打开多个办公软件开始一天的工作，却发现电脑变得异常迟钝，很可能就是 Superfetch 服务在后台大量占用 CPU 资源，使得其他程序无法及时获取足够的运算资源来启动。</p>
<p>同时，Superfetch 会将预读取的数据存储在内存中，这无疑会占用相当一部分内存空间。对于那些内存容量本身就不大的电脑来说，这可能会导致系统内存紧张。当内存不足时，系统会频繁地进行内存与硬盘之间的数据交换，也就是我们常说的 “虚拟内存” 操作，这会大大降低系统的运行效率，使电脑整体变得卡顿，严重影响用户体验。</p>
<h3 id="对-SSD-优化作用小"><a href="#对-SSD-优化作用小" class="headerlink" title="对 SSD 优化作用小"></a>对 SSD 优化作用小</h3><p>在固态硬盘（SSD）普及之前，Superfetch 服务对于提升机械硬盘的读取速度效果显著。因为机械硬盘的读写速度相对较慢，通过预读取数据到内存，可以有效减少等待时间。然而，随着 SSD 的广泛应用，情况发生了变化。SSD 采用闪存芯片作为存储介质，其随机读写速度比机械硬盘快了数倍甚至数十倍，能够在极短的时间内读取大量数据。在这种情况下，Superfetch 服务提前预取数据的优势就不再那么明显，其对系统性能的提升效果变得微乎其微。许多用户发现，即使禁用了 Superfetch 服务，使用 SSD 的电脑在程序启动速度和系统响应速度上依然表现出色，并没有因为缺少了 Superfetch 的预取功能而受到明显影响。</p>
<h3 id="导致硬盘占用率高"><a href="#导致硬盘占用率高" class="headerlink" title="导致硬盘占用率高"></a>导致硬盘占用率高</h3><p>有时候，Superfetch 服务可能会出现异常情况，导致硬盘占用率居高不下。这是因为它在预取数据时，可能会频繁地对硬盘进行读写操作。当硬盘的读写任务过于繁重时，就会出现 100% 占用的情况，此时电脑会变得异常卡顿，几乎无法进行正常操作。比如，你正在使用电脑进行视频剪辑或者玩大型游戏，突然发现电脑变得反应迟缓，打开文件或者切换程序都要等待很长时间，查看任务管理器后发现硬盘占用率达到了 100%，而罪魁祸首很可能就是 Superfetch 服务。这种异常情况不仅会影响当前正在进行的工作和娱乐，还可能对硬盘的寿命产生一定的影响。</p>
<h2 id="禁用-Superfetch-服务的详细步骤"><a href="#禁用-Superfetch-服务的详细步骤" class="headerlink" title="禁用 Superfetch 服务的详细步骤"></a>禁用 Superfetch 服务的详细步骤</h2><p>不同版本的 Windows 系统，禁用 Superfetch 服务的方法略有差异，下面分别为大家介绍 Windows 7、Windows 10 和 Windows 11 系统下的具体操作步骤。</p>
<h3 id="Windows-7-系统"><a href="#Windows-7-系统" class="headerlink" title="Windows 7 系统"></a>Windows 7 系统</h3><ol>
<li><p><strong>打开服务管理器</strong>：同时按下键盘上的<code>Win + R</code>组合键，调出 “运行” 对话框，在对话框中输入<code>services.msc</code>，然后按下回车键<code>Enter</code>，即可打开服务管理器窗口。</p>
</li>
<li><p><strong>找到 Superfetch 服务</strong>：在服务管理器窗口中，会显示出众多系统服务，这些服务按照字母顺序排列。我们需要在列表中仔细查找名为 “Superfetch” 的服务。</p>
</li>
<li><p><strong>停止 Superfetch 服务</strong>：找到 “Superfetch” 服务后，双击该服务，打开其属性窗口。在属性窗口的 “常规” 标签页中，将 “启动类型” 从原来的 “自动” 设置为 “已禁用”。设置完成后，点击 “停止” 按钮，此时 Superfetch 服务就会停止运行。</p>
</li>
<li><p><strong>保存设置</strong>：点击 “确定” 按钮，保存我们所做的更改设置。这样，在下次系统启动时，Superfetch 服务就不会自动运行了。</p>
</li>
</ol>
<h3 id="Windows-10-系统"><a href="#Windows-10-系统" class="headerlink" title="Windows 10 系统"></a>Windows 10 系统</h3><ol>
<li><p><strong>打开计算机管理</strong>：在 Windows 10 桌面，右键点击 “此电脑” 图标，在弹出的菜单中选择 “管理” 菜单项，即可打开计算机管理窗口。</p>
</li>
<li><p><strong>进入服务选项</strong>：在打开的计算机管理窗口中，点击左侧列表中的 “服务和应用程序” 一项，展开该项后，再点击 “服务” 菜单项 ，此时在窗口右侧会显示出所有的系统服务列表。</p>
</li>
<li><p><strong>找到并设置 Superfetch 服务</strong>：在服务列表中找到 “superfetch” 一项，双击它打开 “superfetch” 的属性窗口。首先点击 “停止” 按钮，关闭当前正在运行的 superfetch 服务。然后为了防止下次开机时该服务自动启动，点击 “启动类型” 下拉菜单，在弹出的菜单中选择 “禁用” 菜单项。</p>
</li>
<li><p><strong>确认保存</strong>：完成上述设置后，点击 “确定” 按钮保存设置，关闭属性窗口即可。</p>
</li>
</ol>
<h3 id="Windows-11-系统"><a href="#Windows-11-系统" class="headerlink" title="Windows 11 系统"></a>Windows 11 系统</h3><ol>
<li><p><strong>使用服务应用程序</strong>：按下<code>Windows+S</code>组合键启动 “搜索” 菜单，在顶部的文本字段中输入 “服务”，然后单击相关搜索结果。在打开的服务窗口中找到 “SysMain” 条目（在 Windows 11 中 Superfetch 服务改名为 SysMain ），右键单击它，然后从上下文菜单中选择 “属性”，或者直接双击该服务。在弹出的属性窗口中，单击 “启动类型” 下拉菜单，然后从选项列表中选择 “禁用”。接下来，如果当前服务正在运行，请单击 “服务状态” 下的 “停止” 按钮，最后单击底部的 “确定” 以保存更改。完成后重新启动计算机，以使更改生效。</p>
</li>
<li><p><strong>使用命令提示符</strong>：按下<code>Windows+S</code>组合键启动搜索菜单，在文本字段中输入 “终端”，右键单击相关搜索结果，然后从上下文菜单中选择 “以管理员身份运行”。在弹出的用户帐户控制（UAC）提示中单击 “是”。单击顶部的向下箭头，然后选择 “Command Prompt”（命令提示符）。或者，也可以按下<code>Ctrl+Shift+2</code>组合键在新选项卡中启动命令提示符。在命令提示符窗口中，粘贴以下命令并点击<code>Enter</code>键停止服务：<code>net.exe stop sysmain</code>。接着，执行以下命令以禁用 Superfetch 在启动时加载：<code>sc config sysmain start=disabled</code>。</p>
</li>
<li><p><strong>使用注册表编辑器</strong>：按下<code>Windows+R</code>组合键启动运行命令，在文本字段中输入<code>regedit</code>，然后单击 “确定” 或点击<code>Enter</code>键启动注册表编辑器。在弹出的 UAC 提示中单击 “是”。在注册表编辑器中，将以下路径粘贴到顶部的地址栏中，然后点击<code>Enter</code>键，或者也可以使用左侧的导航窗格依次展开路径：<code>Computer\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters</code>。在该路径下，右键单击空白区域，将光标悬停在 “新建” 上，然后从上下文菜单中选择 “DWORD（32 位）值”。将该条目命名为 “EnableSuperfetch”，然后双击它以修改属性。在 “数值数据” 下的文本字段中输入 “0” ，然后单击 “确定” 以保存更改。进行更改后，重新启动计算机以使更改生效。不过使用注册表编辑器时需格外小心，错误的修改可能会导致系统出现严重问题。</p>
</li>
</ol>
<h2 id="禁用-Superfetch-服务后的影响"><a href="#禁用-Superfetch-服务后的影响" class="headerlink" title="禁用 Superfetch 服务后的影响"></a>禁用 Superfetch 服务后的影响</h2><p>禁用 Superfetch 服务，犹如在电脑的系统生态中做出一次关键的 “调整”，这一操作会带来多方面的影响，既可能有性能提升的惊喜，也可能伴随着一些负面效应，需要我们全面客观地去看待。</p>
<h3 id="可能的性能提升"><a href="#可能的性能提升" class="headerlink" title="可能的性能提升"></a>可能的性能提升</h3><ol>
<li><p><strong>释放系统资源</strong>：正如前文所提到的，Superfetch 服务在运行时会占用一定的 CPU 和内存资源。当我们禁用它后，这些被占用的资源将被释放出来，可供其他程序使用。对于那些配置相对较低的电脑而言，这无疑是个好消息。例如，一台只有 4GB 内存的笔记本电脑，在禁用 Superfetch 服务后，原本被其占用的几百 MB 内存得以释放，电脑在运行多个程序时，内存不再那么紧张，程序之间的切换也变得更加流畅，不容易出现因内存不足而导致的卡顿现象。</p>
</li>
<li><p><strong>减少硬盘读写</strong>：Superfetch 服务为了实现预取功能，会频繁地对硬盘进行读写操作。尤其是在系统启动和程序运行初期，这种读写操作更为明显。禁用该服务后，硬盘的读写负担将大大减轻。对于使用机械硬盘的电脑来说，这可以有效减少硬盘的磨损，延长硬盘的使用寿命；而对于固态硬盘，虽然其读写速度快，但减少不必要的读写操作也有助于降低固态硬盘的写入放大效应，从而延长其寿命，同时也能减少因硬盘读写而产生的热量。</p>
</li>
<li><p><strong>特定场景下的性能提升</strong>：在某些特定场景中，禁用 Superfetch 服务能够显著提升系统性能。比如，对于一些追求极致游戏性能的玩家来说，在玩大型游戏时，禁用 Superfetch 服务可以避免其在后台占用资源，使游戏能够获得更多的系统资源，从而提升游戏的帧率和稳定性，减少游戏过程中的卡顿现象，让玩家能够更加流畅地享受游戏带来的乐趣。又或者对于从事视频剪辑、3D 建模等对系统性能要求较高的专业用户来说，禁用 Superfetch 服务后，他们在使用这些专业软件时，软件的响应速度会更快，操作更加流畅，能够大大提高工作效率。</p>
</li>
</ol>
<h3 id="潜在的负面影响"><a href="#潜在的负面影响" class="headerlink" title="潜在的负面影响"></a>潜在的负面影响</h3><ol>
<li><p><strong>系统启动和程序加载变慢</strong>：Superfetch 服务的核心作用是提前预取系统和程序运行所需的数据，从而加快系统启动和程序加载速度。一旦禁用它，系统在启动时就无法提前将常用程序的数据加载到内存中，程序在启动时也需要从硬盘中实时读取数据，这必然会导致系统启动时间变长，程序的首次加载速度明显变慢。例如，原本开机后几秒钟就能快速启动的微信，在禁用 Superfetch 服务后，可能需要等待十几秒甚至更长时间才能打开，这对于那些追求高效、希望能够快速进入工作或娱乐状态的用户来说，无疑是一种困扰。</p>
</li>
<li><p><strong>内存管理可能受影响</strong>：Superfetch 服务在一定程度上参与了系统的内存管理，它通过分析用户的使用习惯，合理地将数据预加载到内存中，使得内存的使用更加高效。当禁用该服务后，系统的内存管理可能会受到一定影响。内存中可能无法及时存放常用程序的数据，导致程序在运行过程中频繁地进行内存与硬盘之间的数据交换，增加了系统的负担，进而可能影响到系统的整体性能和稳定性，使电脑在运行多个程序时容易出现卡顿现象。</p>
</li>
<li><p><strong>影响用户体验</strong>：从整体用户体验的角度来看，禁用 Superfetch 服务带来的启动和加载变慢问题，可能会让用户在日常使用电脑的过程中感到烦躁和不便。尤其是在当今快节奏的生活和工作环境下，时间的碎片化使得用户希望每一次使用电脑都能够快速、高效地完成任务，而这种等待时间的增加无疑与用户的期望背道而驰，可能会降低用户对电脑使用的满意度 。</p>
</li>
</ol>
<h2 id="如何判断是否适合禁用-Superfetch-服务"><a href="#如何判断是否适合禁用-Superfetch-服务" class="headerlink" title="如何判断是否适合禁用 Superfetch 服务"></a>如何判断是否适合禁用 Superfetch 服务</h2><p>禁用 Superfetch 服务并非适用于所有用户和所有电脑，在决定是否禁用之前，我们需要综合多方面因素进行判断，找到最适合自己电脑的设置方案 。</p>
<h3 id="依据电脑配置判断"><a href="#依据电脑配置判断" class="headerlink" title="依据电脑配置判断"></a>依据电脑配置判断</h3><ol>
<li><p><strong>低配置电脑</strong>：如果你的电脑配置较低，例如 CPU 性能较弱、内存容量较小（4GB 及以下），且使用的是机械硬盘，那么禁用 Superfetch 服务可能会为你带来一定的性能提升。因为这类电脑本身资源有限，Superfetch 服务占用的资源可能会对其他程序的运行产生较大影响。禁用它后，可以释放出更多的系统资源，让电脑运行更加流畅。</p>
</li>
<li><p><strong>高配置电脑</strong>：对于高配置电脑，如配备高性能 CPU、大容量内存（16GB 及以上）以及快速的固态硬盘，Superfetch 服务所占用的资源相对来说对系统整体性能的影响较小。在这种情况下，保留 Superfetch 服务可能会使系统和程序的启动速度更快，用户体验更好，因此不一定需要禁用它。</p>
</li>
</ol>
<h3 id="根据使用习惯判断"><a href="#根据使用习惯判断" class="headerlink" title="根据使用习惯判断"></a>根据使用习惯判断</h3><ol>
<li><p><strong>固定使用场景</strong>：如果你每天使用电脑的场景比较固定，总是运行相同的几个程序，那么 Superfetch 服务能够很好地发挥其预取作用，提前加载常用程序，减少等待时间。这种情况下，保留该服务会更符合你的使用需求。比如，你是一名上班族，每天主要使用办公软件（Word、Excel、PPT）、通讯工具（微信、QQ）以及浏览器进行工作，Superfetch 服务能够根据你的使用习惯，提前将这些程序所需的数据加载到内存中，让你能够快速进入工作状态。</p>
</li>
<li><p><strong>频繁切换使用场景</strong>：然而，如果你经常在不同的使用场景之间切换，运行各种不同类型的程序，Superfetch 服务可能无法及时准确地预取到你需要的数据。因为它需要一定的时间来分析你的新使用习惯并进行预取，在这种频繁变化的情况下，其预取效果可能并不理想，此时禁用它可能不会对你的使用造成太大影响。</p>
</li>
</ol>
<h3 id="参考系统性能表现判断"><a href="#参考系统性能表现判断" class="headerlink" title="参考系统性能表现判断"></a>参考系统性能表现判断</h3><ol>
<li><p><strong>系统卡顿明显</strong>：如果你在日常使用电脑的过程中，经常遇到系统卡顿、反应迟缓的情况，并且通过任务管理器等工具发现 Superfetch 服务占用了大量的 CPU、内存或硬盘资源，那么可以尝试禁用该服务，观察系统性能是否有所改善。例如，在打开多个程序时，电脑出现长时间无响应，查看任务管理器发现 Superfetch 服务占用了较高的 CPU 资源，此时禁用它可能会使系统恢复流畅。</p>
</li>
<li><p><strong>系统运行流畅</strong>：相反，如果你的电脑在运行过程中一直表现得很流畅，系统和程序的启动速度也能满足你的需求，那么就没有必要冒险去禁用 Superfetch 服务，以免带来不必要的负面影响。</p>
</li>
</ol>
<h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a>总结与建议</h2><p>禁用 Superfetch 服务，是一把双刃剑，有着明显的利弊两面。从积极的方面来看，它能够释放系统资源，减少对 CPU、内存和硬盘的占用，尤其对于低配置电脑以及机械硬盘，在一定程度上可提升系统运行的流畅度，降低硬盘的读写负担，延长硬盘使用寿命。同时，在特定的使用场景下，比如追求极致游戏性能或专业软件运行效率时，能让电脑将更多资源集中于关键任务，带来更好的性能表现。</p>
<p>然而，我们也不能忽视其负面效应。禁用 Superfetch 服务后，系统启动和程序加载速度会明显变慢，这会在日常使用中增加等待时间，降低工作和娱乐的效率。而且，它还可能影响系统的内存管理机制，导致内存使用不够合理，进而影响系统的整体稳定性和性能。</p>
<p>对于不同用户群体，建议如下：如果你的电脑配置较低，且使用场景较为单一，日常主要运行少数几个固定程序，那么可以尝试禁用 Superfetch 服务，通过释放系统资源来提升电脑的运行流畅度。但在操作之前，务必备份好重要数据，以防万一。</p>
<p>而对于高配置电脑用户，若电脑在运行过程中没有出现明显的资源不足或卡顿问题，保留 Superfetch 服务通常能获得更便捷、高效的使用体验，因为它可以让系统和程序的启动更加迅速。</p>
<p>总之，是否禁用 Superfetch 服务，需要我们根据自身电脑的实际配置、使用习惯以及系统性能表现等多方面因素，进行全面、谨慎的考虑和权衡。在操作过程中，一定要谨慎行事，尤其是涉及到修改系统服务和注册表等关键设置时，以免因不当操作导致系统出现严重问题，影响正常使用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/06/Alpine-%E7%B3%BB%E7%BB%9F%E4%B8%8B-PhpStorm-Git-Tools-%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="l1n6yun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="l1n6yun's Blog">
      <meta itemprop="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | l1n6yun's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/06/Alpine-%E7%B3%BB%E7%BB%9F%E4%B8%8B-PhpStorm-Git-Tools-%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D/" class="post-title-link" itemprop="url">Alpine 系统下 PhpStorm Git Tools 故障修复</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-06 15:32:00" itemprop="dateCreated datePublished" datetime="2025-06-06T15:32:00+08:00">2025-06-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 Alpine Linux 环境中使用 PhpStorm 的 Git 工具时，部分开发者可能会遇到以下错误提示，导致版本控制功能无法正常使用。本文将详细分析问题成因并提供分步解决方案。</p>
<h2 id="错误呈现"><a href="#错误呈现" class="headerlink" title="错误呈现"></a>错误呈现</h2><p>当尝试在 PhpStorm 中更新代码或执行 Git 操作时，控制台会抛出以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Error updating changes: setsid: unrecognized option: w</span><br><span class="line">BusyBox v1.36.1 (2024-06-12 11:52:11 UTC) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: setsid [-c] PROG ARGS</span><br><span class="line"></span><br><span class="line">Run PROG in a new session. PROG will have no controlling terminal</span><br><span class="line">and will not be affected by keyboard signals (^C etc).</span><br><span class="line"></span><br><span class="line">-c Set controlling terminal to stdin</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-83.png" alt="upload successful"></p>
<p><strong>关键问题点</strong>：BusyBox 提供的 setsid 命令不支持<code>-w</code>选项，而 PhpStorm 的 Git 工具可能默认调用了该参数，导致命令执行失败。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>Alpine Linux 默认使用 BusyBox 工具集，其内置的<code>setsid</code>命令仅支持<code>-c</code>选项（设置控制终端），但 PhpStorm 等 IDE 的 Git 插件可能依赖 GNU Core Utilities 中的<code>setsid</code>命令（支持更多选项，如<code>-w</code>）。由于 BusyBox 的<code>setsid</code>与 GNU 版本存在兼容性差异，导致 IDE 调用时参数不匹配。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>以下操作需在终端中以管理员权限（<code>sudo</code>）执行，逐步修复命令冲突问题：</p>
<h3 id="1-查看系统当前-setsid-指向"><a href="#1-查看系统当前-setsid-指向" class="headerlink" title="1. 查看系统当前 setsid 指向"></a>1. 查看系统当前 setsid 指向</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/bin/</span><br><span class="line">ls -al | grep setsid</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-84.png" alt="upload successful"></p>
<ul>
<li>可见当前<code>setsid</code>实际指向 BusyBox 的<code>busybox</code>二进制文件（通过软链接<code>setsid2</code>）。</li>
</ul>
<h3 id="2-重命名原有-setsid-软链接"><a href="#2-重命名原有-setsid-软链接" class="headerlink" title="2. 重命名原有 setsid 软链接"></a>2. 重命名原有 setsid 软链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv setsid setsid2</span><br></pre></td></tr></table></figure>

<ul>
<li>此步骤避免原有 BusyBox 版本的<code>setsid</code>与后续安装的 GNU 版本冲突。</li>
</ul>
<h3 id="3-安装-GNU-Core-Utilities-并拷贝-setsid"><a href="#3-安装-GNU-Core-Utilities-并拷贝-setsid" class="headerlink" title="3. 安装 GNU Core Utilities 并拷贝 setsid"></a>3. 安装 GNU Core Utilities 并拷贝 setsid</h3><p>Alpine 默认仓库中的<code>coreutils</code>包提供 GNU 版本的工具集，执行以下命令安装并复制<code>setsid</code>：</p>
<p>下载地址：<a href="/files/setsid">setsid</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp setsid /usr/bin/setsid</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：若<code>coreutils</code>安装后<code>setsid</code>路径不同（如<code>/usr/bin/setsid</code>已存在），请根据实际路径调整拷贝命令。</p>
<h3 id="4-设置执行权限"><a href="#4-设置执行权限" class="headerlink" title="4. 设置执行权限"></a>4. 设置执行权限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /usr/bin/setsid</span><br></pre></td></tr></table></figure>

<ul>
<li>赋予文件完整权限，确保 PhpStorm 可正常调用。</li>
</ul>
<p><img src="/images/pasted-85.png" alt="upload successful"></p>
<h2 id="验证修复效果"><a href="#验证修复效果" class="headerlink" title="验证修复效果"></a>验证修复效果</h2><ol>
<li>重启 PhpStorm，再次尝试 Git 操作（如拉取、提交代码）。</li>
<li>若控制台不再出现<code>setsid: unrecognized option: w</code>错误，则说明修复成功。</li>
<li>如需进一步验证，可在终端直接执行<code>setsid -w echo test</code>，若正常输出<code>test</code>且无报错，表明 GNU 版本的<code>setsid</code>已生效。</li>
</ol>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><ul>
<li><strong>原理总结</strong>：通过替换 BusyBox 的<code>setsid</code>为 GNU 版本，解决 IDE 参数调用不兼容问题。</li>
<li><strong>注意事项</strong>：修改系统二进制文件需谨慎操作，建议提前备份原有文件（如复制<code>setsid2</code>到其他目录）。</li>
<li><strong>扩展场景</strong>：类似问题可能出现在其他依赖 GNU 工具的 IDE 或脚本中，均可通过安装<code>coreutils</code>并替换对应命令解决。</li>
</ul>
<p>通过以上步骤，即可在 Alpine 系统中恢复 PhpStorm 的 Git 工具正常使用，确保开发流程不受环境差异影响。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/10/%E8%A7%A3%E9%94%81-MySQL-%E6%A0%91%E5%BD%A2%E6%9F%A5%E8%AF%A2%E6%96%B0%E5%A7%BF%E5%8A%BF%EF%BC%9A%E9%80%92%E5%BD%92-CTE-%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="l1n6yun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="l1n6yun's Blog">
      <meta itemprop="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | l1n6yun's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/10/%E8%A7%A3%E9%94%81-MySQL-%E6%A0%91%E5%BD%A2%E6%9F%A5%E8%AF%A2%E6%96%B0%E5%A7%BF%E5%8A%BF%EF%BC%9A%E9%80%92%E5%BD%92-CTE-%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">解锁 MySQL 树形查询新姿势：递归 CTE 实战指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-10 10:10:34" itemprop="dateCreated datePublished" datetime="2025-05-10T10:10:34+08:00">2025-05-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MySQL-递归-CTE-基础概念"><a href="#MySQL-递归-CTE-基础概念" class="headerlink" title="MySQL 递归 CTE 基础概念"></a>MySQL 递归 CTE 基础概念</h2><h3 id="1-什么是递归-CTE？"><a href="#1-什么是递归-CTE？" class="headerlink" title="1 什么是递归 CTE？"></a>1 什么是递归 CTE？</h3><p>递归公用表表达式（Recursive CTE）是 MySQL 8.0 引入的高级特性，通过<code>WITH RECURSIVE</code>语法定义，允许在 CTE 内部递归引用自身，专门用于处理具有层级关系的树形数据，如组织架构、分类目录、文件系统等。其核心思想是通过锚成员（初始查询）和递归成员（迭代查询）的结合，逐层扩展结果集，直至满足终止条件（递归成员返回空集）。</p>
<h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2 适用场景"></a>2 适用场景</h3><p><strong>组织架构管理</strong>：查询某个部门的所有上下级节点。</p>
<p><strong>分类目录遍历</strong>：获取商品分类的全层级路径。</p>
<p><strong>树状结构分析</strong>：查找节点的所有祖先或后代，替代传统自连接或存储过程的复杂逻辑。</p>
<h2 id="递归-CTE-语法解析与执行逻辑"><a href="#递归-CTE-语法解析与执行逻辑" class="headerlink" title="递归 CTE 语法解析与执行逻辑"></a>递归 CTE 语法解析与执行逻辑</h2><h3 id="1-核心语法结构"><a href="#1-核心语法结构" class="headerlink" title="1 核心语法结构"></a>1 核心语法结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte_name (column_list) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 锚成员：定义递归初始条件，返回基础结果集</span></span><br><span class="line">    initial_query    </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span>  <span class="comment">-- 必须使用UNION ALL，确保递归过程高效合并结果</span></span><br><span class="line">    <span class="comment">-- 递归成员：引用CTE名称，定义迭代规则</span></span><br><span class="line">    recursive_query   </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最终查询：基于CTE结果集进行筛选或关联</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> cte_name;</span><br></pre></td></tr></table></figure>

<h3 id="2-执行流程详解"><a href="#2-执行流程详解" class="headerlink" title="2 执行流程详解"></a>2 执行流程详解</h3><p><strong>锚成员执行</strong>：生成初始结果集（R0），如指定节点的基础信息。</p>
<p><strong>递归迭代</strong>：将上一次结果集（Ri）作为输入，通过<code>UNION ALL</code>合并新生成的结果集（Ri+1），直到递归成员返回空集。</p>
<p><strong>终止条件</strong>：隐式终止于递归成员无数据返回，或显式通过条件（如<code>WHERE n &lt; 100</code>）限制递归深度。</p>
<h3 id="3-递归成员限制"><a href="#3-递归成员限制" class="headerlink" title="3 递归成员限制"></a>3 递归成员限制</h3><p>禁止使用聚合函数（如<code>SUM</code>&#x2F;<code>COUNT</code>）、<code>GROUP BY</code>、<code>ORDER BY</code>、<code>LIMIT</code>、<code>DISTINCT</code>（<code>UNION DISTINCT</code>除外）。</p>
<p>仅能引用 CTE 名称，不能嵌套子查询。</p>
<h2 id="典型场景与实战案例"><a href="#典型场景与实战案例" class="headerlink" title="典型场景与实战案例"></a>典型场景与实战案例</h2><h3 id="1-查询节点所有父节点（向上递归）"><a href="#1-查询节点所有父节点（向上递归）" class="headerlink" title="1 查询节点所有父节点（向上递归）"></a>1 查询节点所有父节点（向上递归）</h3><p><strong>场景</strong>：从子节点出发，逐层查找所有上级节点（如员工查询其所有管理层级）。<strong>表结构</strong>：<code>club(id, name, pid)</code>，<code>pid</code>为父节点 ID，根节点<code>pid</code>为<code>NULL</code>。<strong>SQL 示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> parent_path <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 锚成员：初始节点（如id=5的子节点）</span></span><br><span class="line">    <span class="keyword">SELECT</span> id, name, pid <span class="keyword">FROM</span> club <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>    </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span>    </span><br><span class="line">    <span class="comment">-- 递归成员：通过pid关联，获取父节点</span></span><br><span class="line">    <span class="keyword">SELECT</span> p.id, p.name, p.pid <span class="keyword">FROM</span> club p <span class="keyword">JOIN</span> parent_path pp <span class="keyword">ON</span> p.id <span class="operator">=</span> pp.pid    </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> parent_path;</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong>：从 id&#x3D;5 开始，每次递归通过<code>pid</code>找到父节点，直至无更高层级节点。</p>
<h3 id="2-查询节点所有子节点（向下递归）"><a href="#2-查询节点所有子节点（向下递归）" class="headerlink" title="2 查询节点所有子节点（向下递归）"></a>2 查询节点所有子节点（向下递归）</h3><p><strong>场景</strong>：从父节点出发，获取其所有直接及间接子节点（如部门主管查询下属团队）。<strong>SQL 示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> child_path <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id, name, pid <span class="keyword">FROM</span> club <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span>  <span class="comment">-- 锚成员：初始父节点</span></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span>    </span><br><span class="line">    <span class="comment">-- 递归成员：通过子节点pid关联父节点id</span></span><br><span class="line">    <span class="keyword">SELECT</span> c.id, c.name, c.pid <span class="keyword">FROM</span> club c <span class="keyword">JOIN</span> child_path cp <span class="keyword">ON</span> c.pid <span class="operator">=</span> cp.id    </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child_path;</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong>：以 id&#x3D;3 为起点，逐层匹配<code>pid=当前id</code>的子节点，实现无限层级遍历。</p>
<h3 id="3-添加层级标识（Level-字段）"><a href="#3-添加层级标识（Level-字段）" class="headerlink" title="3 添加层级标识（Level 字段）"></a>3 添加层级标识（Level 字段）</h3><p><strong>场景</strong>：在查询结果中显式节点层级，方便分页或排序（如目录树展示）。<strong>SQL 示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> level_tree <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id, name, pid, <span class="number">1</span> <span class="keyword">AS</span> level <span class="keyword">FROM</span> club <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>  <span class="comment">-- 根节点层级为1</span></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span>    </span><br><span class="line">    <span class="keyword">SELECT</span> c.id, c.name, c.pid, ct.level <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> level  <span class="comment">-- 子节点层级=父层级+1</span></span><br><span class="line">    <span class="keyword">FROM</span> club c <span class="keyword">JOIN</span> level_tree ct <span class="keyword">ON</span> c.pid <span class="operator">=</span> ct.id    </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 筛选层级&gt;3的深层子节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> id, name, pid, level <span class="keyword">FROM</span> level_tree <span class="keyword">WHERE</span> level <span class="operator">&gt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong>：通过<code>level</code>字段量化层级深度，避免表设计时预存层级的冗余问题。</p>
<h3 id="4-实战优化：业务层与-SQL-层解耦"><a href="#4-实战优化：业务层与-SQL-层解耦" class="headerlink" title="4 实战优化：业务层与 SQL 层解耦"></a>4 实战优化：业务层与 SQL 层解耦</h3><p><strong>场景</strong>：传统 Java&#x2F;Python 代码中，递归遍历组织架构易导致性能瓶颈，改用递归 CTE 后可在数据库层高效完成。<strong>MyBatis 映射示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> DeptTree <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> id_ <span class="keyword">FROM</span> org_group <span class="keyword">WHERE</span> id_ <span class="operator">=</span> #&#123;deptId&#125;  <span class="comment">-- 锚成员：目标部门</span></span><br><span class="line">  <span class="keyword">UNION</span> <span class="keyword">ALL</span>    </span><br><span class="line">  <span class="keyword">SELECT</span> og.id_ <span class="keyword">FROM</span> org_group og <span class="keyword">JOIN</span> DeptTree dt <span class="keyword">ON</span> og.parent_id_ <span class="operator">=</span> dt.id_  <span class="comment">-- 递归获取子部门</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> su.<span class="operator">*</span> <span class="keyword">FROM</span> sys_user su <span class="keyword">JOIN</span> DeptTree dt <span class="keyword">ON</span> su.dept_id <span class="operator">=</span> dt.id_</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>：避免多次往返数据库，单条 SQL 完成层级查询，提升系统响应速度。</p>
<h2 id="注意事项与最佳实践"><a href="#注意事项与最佳实践" class="headerlink" title="注意事项与最佳实践"></a>注意事项与最佳实践</h2><h3 id="1-MySQL-版本要求"><a href="#1-MySQL-版本要求" class="headerlink" title="1 MySQL 版本要求"></a>1 MySQL 版本要求</h3><p>仅支持 MySQL 8.0 及以上版本，低版本需使用存储过程或应用层递归实现。</p>
<h3 id="2-避免死循环"><a href="#2-避免死循环" class="headerlink" title="2 避免死循环"></a>2 避免死循环</h3><p><strong>数据校验</strong>：确保层级数据无环（如 A→B→A），否则递归会因无法终止报错（默认最大递归深度 1000，可通过<code>SET @@cte_max_recursion_depth = N</code>调整）。</p>
<p><strong>条件限制</strong>：在递归成员中添加合理过滤条件（如<code>WHERE level &lt; 50</code>），防止无限递归。</p>
<h3 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3 索引优化"></a>3 索引优化</h3><p>为<code>id</code>和<code>pid</code>字段添加索引，提升递归过程中 JOIN 操作的效率，尤其对大规模层级数据至关重要。</p>
<h3 id="4-结果去重"><a href="#4-结果去重" class="headerlink" title="4 结果去重"></a>4 结果去重</h3><p>若数据存在重复关联，可在最终查询中使用<code>DISTINCT</code>去重，但需注意递归成员中禁止直接使用<code>DISTINCT</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>递归 CTE 是 MySQL 处理树形数据的 “瑞士军刀”，通过简洁的语法将复杂的层级查询转化为结构化的递归过程，显著提升开发效率与查询性能。无论是组织架构、分类目录还是其他层级场景，掌握递归 CTE 的锚成员定义、递归规则设计及终止条件把控，都能让你在数据处理中游刃有余。建议在实际项目中结合索引优化与数据校验，充分发挥其在层级查询中的优势。</p>
<p><strong>动手实践</strong>：尝试在示例表<code>club</code>中插入多级数据，分别编写查询根节点、叶节点及全路径的递归 CTE 语句，观察结果差异与执行效率。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/30/grafana-%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89API%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="l1n6yun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="l1n6yun's Blog">
      <meta itemprop="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | l1n6yun's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/30/grafana-%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89API%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">grafana 通过自定义API获取数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-30 14:30:00" itemprop="dateCreated datePublished" datetime="2025-04-30T14:30:00+08:00">2025-04-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装infinity插件"><a href="#安装infinity插件" class="headerlink" title="安装infinity插件"></a>安装infinity插件</h2><p>在插件页面中搜索 <code>infinity</code>，进入 infinity 插件页面点击 <code>install</code>,等待安装完成。</p>
<p><img src="/images/pasted-79.png" alt="安装infinity插件"></p>
<h2 id="添加数据源"><a href="#添加数据源" class="headerlink" title="添加数据源"></a>添加数据源</h2><p>进入数据源页面，点击 <code>Add new data source</code> 按钮，搜索 <code>infinity</code>。</p>
<p><img src="/images/pasted-80.png" alt="搜索数据源"></p>
<p>进入 infinity 数据源页面，输入 数据源 名称点击 <code>Save &amp; test</code></p>
<p><img src="/images/pasted-81.png" alt="添加数据源"></p>
<h2 id="使用数据源"><a href="#使用数据源" class="headerlink" title="使用数据源"></a>使用数据源</h2><p>在仪表板中添加可视化，在 <code>Data source</code> 选项中选择刚刚新增的数据源。</p>
<p>在 <code>URL</code> 中填写你的接口地址。根据要求返回对应的格式即可呈现到面板上。</p>
<p><img src="/images/pasted-82.png" alt="使用数据源"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/21/Burp-Suite-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="l1n6yun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="l1n6yun's Blog">
      <meta itemprop="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | l1n6yun's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/21/Burp-Suite-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">Burp Suite 中文乱码解决</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-21 15:15:00" itemprop="dateCreated datePublished" datetime="2025-03-21T15:15:00+08:00">2025-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在使用 Burp Suite 进行 HTTP 请求或响应分析时，可能遇到请求参数、响应内容中的中文显示为乱码的情况，例如显示为乱码符号（如方框、问号等），影响数据查看和分析。</p>
<p><img src="/images/pasted-76.png" alt="upload successful"></p>
<p>Burp Suite 默认的字符编码或字体设置与中文不兼容，导致无法正确解析和显示中文字符。常见原因包括：<br>编码格式错误：未设置为 UTF-8（中文通用编码）。<br>字体不支持中文：默认字体无法渲染中文字符。</p>
<p>解决步骤</p>
<ol>
<li><p>进入设置页面</p>
<p> 打开 Burp Suite，点击顶部菜单栏的 Settings（设置），选择 User Interface（用户界面）。</p>
</li>
<li><p>修改消息编辑器的编码和字体</p>
<p> 在左侧导航栏中选择 Message editor（消息编辑器）。</p>
<p> 在右侧的 Character sets（字符编码）下拉菜单中，选择 UTF-8（确保与目标网站的编码一致）。<br> 更换支持中文的字体：</p>
<p> 在 Font（字体）选项中，点击 Change font（选择字体），从列表中选择支持中文的字体（如 Microsoft YaHei、SimSun 或 黑体），调整字体大小至合适显示。</p>
</li>
</ol>
<p><img src="/images/pasted-77.png" alt="upload successful"></p>
<p>修改完成后，就可以正常查看中文字体了</p>
<p><img src="/images/pasted-78.png" alt="upload successful"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/14/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%A5%9E%E5%99%A8PyAutoGUI%EF%BC%8C%E6%95%88%E7%8E%87%E9%A3%99%E5%8D%87%E4%B8%8D%E6%98%AF%E6%A2%A6%EF%BC%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="l1n6yun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="l1n6yun's Blog">
      <meta itemprop="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | l1n6yun's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/14/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E7%A5%9E%E5%99%A8PyAutoGUI%EF%BC%8C%E6%95%88%E7%8E%87%E9%A3%99%E5%8D%87%E4%B8%8D%E6%98%AF%E6%A2%A6%EF%BC%81/" class="post-title-link" itemprop="url">Python自动化神器PyAutoGUI，效率飙升不是梦！</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-14 13:00:00" itemprop="dateCreated datePublished" datetime="2024-12-14T13:00:00+08:00">2024-12-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="PyAutoGUI-是什么"><a href="#PyAutoGUI-是什么" class="headerlink" title="PyAutoGUI 是什么"></a>PyAutoGUI 是什么</h2><p>在 Python 的自动化领域中，PyAutoGUI 是一个非常实用的库，它允许我们通过编写代码来模拟鼠标和键盘的操作，从而实现自动化任务 。无论是重复性的日常工作，还是复杂的软件测试流程，PyAutoGUI 都能发挥重要作用，帮助我们节省时间和精力。</p>
<p>想象一下，你需要在某个软件中重复进行一系列的点击、输入操作，要是手动完成，不仅耗时，还容易出错。但有了 PyAutoGUI，你只需编写一个简单的 Python 脚本，就能让计算机自动执行这些任务。比如自动填写表格、批量处理文件、自动化测试软件功能等，这些操作都能轻松实现。</p>
<h2 id="PyAutoGUI-的安装"><a href="#PyAutoGUI-的安装" class="headerlink" title="PyAutoGUI 的安装"></a>PyAutoGUI 的安装</h2><p>在开始使用 PyAutoGUI 之前，我们需要先将其安装到我们的 Python 环境中。安装 PyAutoGUI 非常简单，使用 pip 命令即可完成 。打开你的命令行工具，输入以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyautogui</span><br></pre></td></tr></table></figure>

<p>如果你使用的是 Python 3.9 或更高版本，也可以使用pip3命令进行安装：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyautogui</span><br></pre></td></tr></table></figure>

<p>安装过程中，pip 会自动下载 PyAutoGUI 及其依赖项 。等待安装完成后，你就可以在 Python 脚本中导入并使用 PyAutoGUI 了。</p>
<p>需要注意的是，在安装之前，请确保你的 Python 环境已经正确配置，并且 pip 已经安装在系统上。如果你在 Windows 操作系统上使用 Python，还要确保已将 Python 添加到系统的环境变量中，以便能够在命令提示符中运行 pip。 如果你在安装过程中遇到问题，可以参考 PyAutoGUI 的官方文档，或者在相关技术论坛上寻求帮助。</p>
<p>PyAutoGUI 的强大功能展示</p>
<h3 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h3><h4 id="1-移动鼠标"><a href="#1-移动鼠标" class="headerlink" title="1. 移动鼠标"></a>1. 移动鼠标</h4><p>在 PyAutoGUI 中，控制鼠标移动主要通过moveTo()和moveRel()函数 。moveTo()函数用于将鼠标移动到屏幕上的指定坐标位置，它的语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.moveTo(x, y, duration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>其中，x和y是目标坐标的横坐标和纵坐标，duration是可选参数，表示鼠标移动到目标位置所需的时间，单位为秒。如果不设置duration，鼠标会瞬间移动到指定位置。例如，要将鼠标移动到屏幕坐标为 (500, 300) 的位置，可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将鼠标移动到坐标(500, 300)，耗时2秒</span></span><br><span class="line">pyautogui.moveTo(<span class="number">500</span>, <span class="number">300</span>, duration=<span class="number">2</span>) </span><br></pre></td></tr></table></figure>

<p>moveRel()函数则是相对于当前鼠标位置进行移动，语法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.moveRel(xOffset, yOffset, duration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>xOffset和yOffset分别是水平和垂直方向上的偏移量，正数表示向右和向下移动，负数表示向左和向上移动。同样，duration是移动所需的时间。比如，要让鼠标在当前位置的基础上向右移动 100 个像素，向下移动 50 个像素，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标在当前位置基础上，向右移动100像素，向下移动50像素，耗时1秒</span></span><br><span class="line">pyautogui.moveRel(<span class="number">100</span>, <span class="number">50</span>, duration=<span class="number">1</span>) </span><br></pre></td></tr></table></figure>

<h4 id="2-点击操作"><a href="#2-点击操作" class="headerlink" title="2. 点击操作"></a>2. 点击操作</h4><p>PyAutoGUI 提供了多个函数来实现鼠标的点击操作，包括click()、doubleClick()、rightClick()和middleClick()等 。click()函数是最常用的点击函数，它可以模拟鼠标的左键点击、右键点击以及中键点击，还可以设置点击的次数和间隔时间。语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.click(x=<span class="literal">None</span>, y=<span class="literal">None</span>, clicks=<span class="number">1</span>, interval=<span class="number">0.0</span>, button=<span class="string">&#x27;left&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>x和y是点击的坐标位置，如果不指定则在当前鼠标位置点击；clicks表示点击的次数，默认为 1 次；interval是每次点击之间的间隔时间，单位为秒；button指定点击的鼠标按钮，可选值为 ‘left’。例如，要在坐标 (400, 200) 处进行两次左键点击，每次点击间隔 0.5 秒，可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在坐标(400, 200)处进行两次左键点击，每次间隔0.5秒</span></span><br><span class="line">pyautogui.click(<span class="number">400</span>, <span class="number">200</span>, clicks=<span class="number">2</span>, interval=<span class="number">0.5</span>) </span><br></pre></td></tr></table></figure>

<p>doubleClick()函数专门用于模拟鼠标左键的双击操作，语法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.doubleClick(x=<span class="literal">None</span>, y=<span class="literal">None</span>, interval=<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>

<p>x和y是双击的坐标位置，interval是两次点击之间的间隔时间。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前鼠标位置进行双击</span></span><br><span class="line">pyautogui.doubleClick() </span><br></pre></td></tr></table></figure>

<p>rightClick()和middleClick()函数分别用于模拟鼠标右键点击和中键点击，语法类似，只需在调用时传入相应的坐标位置即可。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在坐标(300, 100)处进行右键点击</span></span><br><span class="line">pyautogui.rightClick(<span class="number">300</span>, <span class="number">100</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在坐标(200, 150)处进行中键点击</span></span><br><span class="line">pyautogui.middleClick(<span class="number">200</span>, <span class="number">150</span>) </span><br></pre></td></tr></table></figure>

<h4 id="3-鼠标拖拽"><a href="#3-鼠标拖拽" class="headerlink" title="3. 鼠标拖拽"></a>3. 鼠标拖拽</h4><p>实现鼠标拖拽操作的函数是dragTo()和dragRel() 。dragTo()函数将鼠标从当前位置拖动到指定的坐标位置，语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.dragTo(x, y, duration=<span class="number">0</span>, button=<span class="string">&#x27;left&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>x和y是目标坐标，duration是拖动所需的时间，button指定拖动时使用的鼠标按钮，默认为左键。比如，要将鼠标从当前位置拖动到坐标 (600, 400) 处，耗时 3 秒，可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从当前位置将鼠标拖动到坐标(600, 400)，耗时3秒，使用左键</span></span><br><span class="line">pyautogui.dragTo(<span class="number">600</span>, <span class="number">400</span>, duration=<span class="number">3</span>) </span><br></pre></td></tr></table></figure>

<p>dragRel()函数则是相对于当前鼠标位置进行拖动，语法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.dragRel(xOffset, yOffset, duration=<span class="number">0</span>, button=<span class="string">&#x27;left&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>xOffset和yOffset是水平和垂直方向上的偏移量，duration是拖动时间，button是鼠标按钮。例如，要让鼠标在当前位置的基础上，向右拖动 80 个像素，向上拖动 30 个像素，耗时 2 秒，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标在当前位置基础上，向右拖动80像素，向上拖动30像素，耗时2秒，使用左键</span></span><br><span class="line">pyautogui.dragRel(<span class="number">80</span>, -<span class="number">30</span>, duration=<span class="number">2</span>) </span><br></pre></td></tr></table></figure>

<h4 id="4-鼠标滚动"><a href="#4-鼠标滚动" class="headerlink" title="4. 鼠标滚动"></a>4. 鼠标滚动</h4><p>控制鼠标滚轮滚动的函数是scroll()，语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.scroll(clicks)</span><br></pre></td></tr></table></figure>

<p>clicks是一个整数参数，表示滚动的距离，正数表示向上滚动，负数表示向下滚动。例如，要让鼠标滚轮向上滚动 5 个单位，可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标滚轮向上滚动5个单位</span></span><br><span class="line">pyautogui.scroll(<span class="number">5</span>) </span><br></pre></td></tr></table></figure>

<p>如果要向下滚动 10 个单位，则可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标滚轮向下滚动10个单位</span></span><br><span class="line">pyautogui.scroll(-<span class="number">10</span>) </span><br></pre></td></tr></table></figure>

<h3 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h3><h4 id="1-按键模拟"><a href="#1-按键模拟" class="headerlink" title="1. 按键模拟"></a>1. 按键模拟</h4><p>在 PyAutoGUI 中，模拟按键按下和释放主要使用press()、keyDown()和keyUp()函数 。press()函数用于模拟按下并释放一个按键，语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.press(key)</span><br></pre></td></tr></table></figure>

<p>key是要按下的按键名称，可以是单个字符，如 ‘a’、’b’，也可以是特殊按键，如 ‘enter’等。例如，要模拟按下回车键，可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟按下回车键</span></span><br><span class="line">pyautogui.press(<span class="string">&#x27;enter&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p>keyDown()函数用于模拟按下一个按键，而不释放，语法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.keyDown(key)</span><br></pre></td></tr></table></figure>

<p>keyUp()函数则用于模拟释放一个按键，语法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.keyUp(key)</span><br></pre></td></tr></table></figure>

<p>这两个函数通常一起使用，以实现对按键的精确控制。例如，要模拟按住 Shift 键的同时按下 ‘a’ 键，然后释放 Shift 键，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按下Shift键</span></span><br><span class="line">pyautogui.keyDown(<span class="string">&#x27;shift&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 按下&#x27;a&#x27;键</span></span><br><span class="line">pyautogui.press(<span class="string">&#x27;a&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放Shift键</span></span><br><span class="line">pyautogui.keyUp(<span class="string">&#x27;shift&#x27;</span>) </span><br></pre></td></tr></table></figure>

<h4 id="2-文本输入"><a href="#2-文本输入" class="headerlink" title="2. 文本输入"></a>2. 文本输入</h4><p>实现自动化文本输入的函数是typewrite()，语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.typewrite(message, interval=<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>

<p>message是要输入的文本内容，可以是字符串；interval是可选参数，表示输入每个字符之间的时间间隔，单位为秒。例如，要在当前光标位置输入 “Hello, World!”，每个字符之间间隔 0.2 秒，可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入&quot;Hello, World!&quot;，每个字符间隔0.2秒</span></span><br><span class="line">pyautogui.typewrite(<span class="string">&#x27;Hello, World!&#x27;</span>, interval=<span class="number">0.2</span>) </span><br></pre></td></tr></table></figure>

<p>如果要输入包含特殊按键的组合，比如先按 ‘enter’ 键，再输入 “Python”，可以将按键和文本内容放在一个列表中传递给typewrite()函数，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先按&#x27;enter&#x27;键，再输入&quot;Python&quot;</span></span><br><span class="line">pyautogui.typewrite([<span class="string">&#x27;enter&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>]) </span><br></pre></td></tr></table></figure>

<h4 id="3-组合键操作"><a href="#3-组合键操作" class="headerlink" title="3. 组合键操作"></a>3. 组合键操作</h4><p>模拟组合键操作可以使用hotkey()函数，语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.hotkey(*keys)</span><br></pre></td></tr></table></figure>

<p>keys是要组合的按键名称，可以传递多个参数。例如，要模拟按下 Ctrl+C 组合键，可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟按下Ctrl+C组合键</span></span><br><span class="line">pyautogui.hotkey(<span class="string">&#x27;ctrl&#x27;</span>, <span class="string">&#x27;c&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p>同样，要模拟按下 Alt+Tab 组合键，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟按下Alt+Tab组合键</span></span><br><span class="line">pyautogui.hotkey(<span class="string">&#x27;alt&#x27;</span>, <span class="string">&#x27;tab&#x27;</span>) </span><br></pre></td></tr></table></figure>

<h3 id="屏幕操作"><a href="#屏幕操作" class="headerlink" title="屏幕操作"></a>屏幕操作</h3><h4 id="1-屏幕截图"><a href="#1-屏幕截图" class="headerlink" title="1. 屏幕截图"></a>1. 屏幕截图</h4><p>获取屏幕截图的函数是screenshot()，它可以返回一个表示屏幕截图的 Pillow 图像对象 。语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im = pyautogui.screenshot()</span><br></pre></td></tr></table></figure>

<p>im就是返回的图像对象，你可以对其进行保存、分析等操作。例如，要将屏幕截图保存为名为 “screenshot.png” 的文件，可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取屏幕截图并保存为&quot;screenshot.png&quot;</span></span><br><span class="line">im = pyautogui.screenshot()im.save(<span class="string">&#x27;screenshot.png&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p>如果你只想截取屏幕的某个区域，可以使用region参数指定截取区域的左上角坐标和宽度、高度，语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im = pyautogui.screenshot(region=(left, top, width, height))</span><br></pre></td></tr></table></figure>

<p>left和top是截取区域左上角的横坐标和纵坐标，width和height是截取区域的宽度和高度。例如，要截取屏幕左上角坐标为 (100, 100)，宽度为 200，高度为 150 的区域，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取指定区域的屏幕截图</span></span><br><span class="line">im = pyautogui.screenshot(region=(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">150</span>))im.save(<span class="string">&#x27;partial_screenshot.png&#x27;</span>) </span><br></pre></td></tr></table></figure>

<h4 id="2-图像识别定位"><a href="#2-图像识别定位" class="headerlink" title="2. 图像识别定位"></a>2. 图像识别定位</h4><p>在屏幕上查找指定图像位置的函数主要有locateOnScreen()和locateCenterOnScreen() 。locateOnScreen()函数用于在屏幕上查找指定图像的位置，并返回其边界框的坐标，语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location = pyautogui.locateOnScreen(image, grayscale=<span class="literal">False</span>, confidence=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>image是要查找的图像文件名或 Pillow 图像对象；grayscale是可选参数，设置为True时会以灰度模式查找图像，这样可以提高查找速度，但可能会降低准确性；confidence是可选参数，表示匹配的置信度，取值范围为 0 到 1，值越高表示匹配要求越严格，默认值为None，即不进行置信度匹配。location返回一个包含边界框坐标的四元组(left, top, width, height)，如果未找到图像，则返回None。例如，要在屏幕上查找名为 “button.png” 的图像位置，可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在屏幕上查找&quot;button.png&quot;的位置</span></span><br><span class="line">location = pyautogui.locateOnScreen(<span class="string">&#x27;button.png&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> location:    left, top, width, height = location</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">f&#x27;找到图像，位置为：(<span class="subst">&#123;left&#125;</span>, <span class="subst">&#123;top&#125;</span>)，宽度为：<span class="subst">&#123;width&#125;</span>，高度为：<span class="subst">&#123;height&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;未找到图像&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>locateCenterOnScreen()函数则是在屏幕上查找指定图像的位置，并返回其中心点的坐标，语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">center = pyautogui.locateCenterOnScreen(image, grayscale=<span class="literal">False</span>, confidence=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>center返回一个包含中心点坐标的二元组(x, y)，如果未找到图像，则返回None。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="comment"># 在屏幕上查找&quot;icon.png&quot;的中心点位置</span></span><br><span class="line">center = pyautogui.locateCenterOnScreen(<span class="string">&#x27;icon.png&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> center:</span><br><span class="line">	x, y = center</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;找到图像，中心点位置为：(<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;未找到图像&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这些屏幕操作函数结合鼠标和键盘操作函数，可以实现更加复杂的自动化任务，比如根据屏幕上的图像位置进行点击、输入等操作。</p>
<p>实战应用案例</p>
<p>自动化测试</p>
<p>假设我们正在开发一款简单的图形界面应用程序，其中有一个登录窗口，包含用户名输入框、密码输入框和登录按钮 。我们可以使用 PyAutoGUI 编写自动化测试脚本来模拟用户登录操作，检查应用程序的登录功能是否正常。以下是一个简单的示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟打开应用程序</span></span><br><span class="line">app_icon_location = pyautogui.locateCenterOnScreen(<span class="string">&#x27;app_icon.png&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> app_icon_location:</span><br><span class="line">    pyautogui.doubleClick(app_icon_location.x, app_icon_location.y)</span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 等待应用程序打开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟输入用户名和密码</span></span><br><span class="line">username_input_location = pyautogui.locateCenterOnScreen(<span class="string">&#x27;username_input.png&#x27;</span>)</span><br><span class="line">password_input_location = pyautogui.locateCenterOnScreen(<span class="string">&#x27;password_input.png&#x27;</span>)</span><br><span class="line">login_button_location = pyautogui.locateCenterOnScreen(<span class="string">&#x27;login_button.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> username_input_location <span class="keyword">and</span> password_input_location <span class="keyword">and</span> login_button_location:</span><br><span class="line">    pyautogui.click(username_input_location.x, username_input_location.y)</span><br><span class="line">    pyautogui.typewrite(<span class="string">&#x27;test_user&#x27;</span>)</span><br><span class="line">    pyautogui.click(password_input_location.x, password_input_location.y)</span><br><span class="line">    pyautogui.typewrite(<span class="string">&#x27;test_password&#x27;</span>)</span><br><span class="line">    pyautogui.click(login_button_location.x, login_button_location.y)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 等待登录结果显示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查登录是否成功</span></span><br><span class="line">    success_dialog_location = pyautogui.locateOnScreen(<span class="string">&#x27;success_dialog.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> success_dialog_location:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;登录测试成功&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;登录测试失败&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;无法找到界面元素，测试终止&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先通过locateCenterOnScreen函数查找应用程序图标、用户名输入框、密码输入框和登录按钮的位置，然后使用click和typewrite函数模拟用户的点击和输入操作 。最后，通过查找登录成功后的提示框来判断登录是否成功。这样，我们就可以自动化地对应用程序的登录功能进行多次测试，大大提高了测试效率和准确性。</p>
<h3 id="数据采集与处理"><a href="#数据采集与处理" class="headerlink" title="数据采集与处理"></a>数据采集与处理</h3><p>比如，我们需要从一个电商网站上采集商品信息，包括商品名称、价格、销量等 。我们可以使用 PyAutoGUI 结合一些图像识别和文本处理技术来实现自动化采集。以下是一个简单的思路和示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开浏览器并访问电商网站</span></span><br><span class="line">pyautogui.hotkey(<span class="string">&#x27;win&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)  <span class="comment"># 打开运行对话框</span></span><br><span class="line">pyautogui.typewrite(<span class="string">&#x27;chrome&#x27;</span>)</span><br><span class="line">pyautogui.press(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">pyautogui.typewrite(<span class="string">&#x27;https://example_ecommerce.com&#x27;</span>)</span><br><span class="line">pyautogui.press(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)  <span class="comment"># 等待页面加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟搜索商品</span></span><br><span class="line">search_box_location = pyautogui.locateCenterOnScreen(<span class="string">&#x27;search_box.png&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> search_box_location:</span><br><span class="line">    pyautogui.click(search_box_location.x, search_box_location.y)</span><br><span class="line">    pyautogui.typewrite(<span class="string">&#x27;手机&#x27;</span>)</span><br><span class="line">    pyautogui.press(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)  <span class="comment"># 等待搜索结果页面加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 采集商品信息</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 假设采集3页商品信息</span></span><br><span class="line">    <span class="comment"># 截取当前页面商品信息区域的屏幕截图</span></span><br><span class="line">    screenshot = pyautogui.screenshot(region=(<span class="number">100</span>, <span class="number">200</span>, <span class="number">800</span>, <span class="number">600</span>))</span><br><span class="line">    screenshot.save(<span class="string">&#x27;product_info.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用OCR识别截图中的文本信息</span></span><br><span class="line">    text = pytesseract.image_to_string(Image.<span class="built_in">open</span>(<span class="string">&#x27;product_info.png&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理识别出的文本，提取商品名称、价格、销量等信息</span></span><br><span class="line">    <span class="comment"># 这里只是简单示例，实际需要更复杂的文本处理逻辑</span></span><br><span class="line">    lines = text.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;价格&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            price = line.split(<span class="string">&#x27;：&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;商品价格：<span class="subst">&#123;price&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;销量&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            sales = line.split(<span class="string">&#x27;：&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;商品销量：<span class="subst">&#123;sales&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟点击下一页按钮</span></span><br><span class="line">    next_page_button_location = pyautogui.locateCenterOnScreen(<span class="string">&#x27;next_page_button.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> next_page_button_location:</span><br><span class="line">        pyautogui.click(next_page_button_location.x, next_page_button_location.y)</span><br><span class="line">        time.sleep(<span class="number">5</span>)  <span class="comment"># 等待下一页加载</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先打开浏览器并访问电商网站，然后模拟搜索商品 。接着，通过截取屏幕上商品信息区域的截图，并使用 OCR 技术识别截图中的文本，从而提取出商品的相关信息。最后，通过模拟点击下一页按钮，实现多页商品信息的采集。</p>
<h3 id="软件演示与教程录制"><a href="#软件演示与教程录制" class="headerlink" title="软件演示与教程录制"></a>软件演示与教程录制</h3><p>假设我们要制作一个关于某个绘图软件使用教程的视频，我们可以使用 PyAutoGUI 自动化演示软件的各种功能，并配合录屏软件进行录制 。以下是一个简单的示例代码，展示如何使用 PyAutoGUI 打开绘图软件并进行一些基本操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟打开绘图软件</span></span><br><span class="line">paint_icon_location = pyautogui.locateCenterOnScreen(<span class="string">&#x27;paint_icon.png&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> paint_icon_location:</span><br><span class="line">    pyautogui.doubleClick(paint_icon_location.x, paint_icon_location.y)</span><br><span class="line">    time.sleep(<span class="number">5</span>)  <span class="comment"># 等待软件打开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 演示绘制一个矩形</span></span><br><span class="line">rectangle_tool_location = pyautogui.locateCenterOnScreen(<span class="string">&#x27;rectangle_tool.png&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> rectangle_tool_location:</span><br><span class="line">    pyautogui.click(rectangle_tool_location.x, rectangle_tool_location.y)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    start_x, start_y = <span class="number">100</span>, <span class="number">100</span></span><br><span class="line">    end_x, end_y = <span class="number">300</span>, <span class="number">300</span></span><br><span class="line">    pyautogui.moveTo(start_x, start_y)</span><br><span class="line">    pyautogui.mouseDown()</span><br><span class="line">    pyautogui.dragTo(end_x, end_y)</span><br><span class="line">    pyautogui.mouseUp()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 演示保存绘制的图形</span></span><br><span class="line">pyautogui.hotkey(<span class="string">&#x27;ctrl&#x27;</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">file_name_input_location = pyautogui.locateCenterOnScreen(<span class="string">&#x27;file_name_input.png&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> file_name_input_location:</span><br><span class="line">    pyautogui.click(file_name_input_location.x, file_name_input_location.y)</span><br><span class="line">    pyautogui.typewrite(<span class="string">&#x27;drawing.png&#x27;</span>)</span><br><span class="line">    pyautogui.press(<span class="string">&#x27;enter&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先通过图像识别找到绘图软件的图标并打开软件 。然后，找到矩形绘制工具并使用鼠标操作绘制一个矩形。最后，演示保存绘制图形的操作。在运行这段代码时，同时开启录屏软件，就可以录制出一个完整的软件使用教程视频，大大提高了制作教程的效率和准确性。</p>
<h3 id="游戏辅助工具"><a href="#游戏辅助工具" class="headerlink" title="游戏辅助工具"></a>游戏辅助工具</h3><p>以简单的扫雷游戏为例，我们可以使用 PyAutoGUI 制作一个辅助工具，帮助玩家自动识别雷区和点击安全区域 。以下是一个简单的实现思路和示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义雷区格子的大小和初始位置</span></span><br><span class="line">cell_size = <span class="number">18</span></span><br><span class="line">left, top = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 假设雷区左上角坐标，实际需要根据屏幕截图识别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数字图片模板，用于识别雷区数字</span></span><br><span class="line">number_templates = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">    template = cv2.imread(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>.png&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    number_templates.append(template)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recognize_number</span>(<span class="params">image</span>):</span><br><span class="line">    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    best_match = <span class="literal">None</span></span><br><span class="line">    best_score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, template <span class="keyword">in</span> <span class="built_in">enumerate</span>(number_templates):</span><br><span class="line">        result = cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)</span><br><span class="line">        <span class="keyword">if</span> max_val &gt; best_score:</span><br><span class="line">            best_score = max_val</span><br><span class="line">            best_match = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> best_match</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_minefield</span>():</span><br><span class="line">    screenshot = pyautogui.screenshot(region=(left, top, cell_size * <span class="number">30</span>, cell_size * <span class="number">16</span>))  <span class="comment"># 假设雷区大小为30x16</span></span><br><span class="line">    screenshot = cv2.cvtColor(numpy.array(screenshot), cv2.COLOR_RGB2BGR)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">16</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">30</span>):</span><br><span class="line">            cell = screenshot[y * cell_size:(y + <span class="number">1</span>) * cell_size, x * cell_size:(x + <span class="number">1</span>) * cell_size]</span><br><span class="line">            number = recognize_number(cell)</span><br><span class="line">            <span class="keyword">if</span> number:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;坐标(<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)处的数字为：<span class="subst">&#123;number&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始分析雷区</span></span><br><span class="line">time.sleep(<span class="number">3</span>)  <span class="comment"># 等待游戏界面加载完成</span></span><br><span class="line">analyze_minefield()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先定义了雷区格子的大小和初始位置，然后加载数字图片模板用于识别雷区中的数字 。recognize_number函数通过模板匹配的方式识别每个格子中的数字，analyze_minefield函数则对整个雷区进行截图并分析每个格子的数字。通过这种方式，我们可以根据识别出的数字来判断哪些区域是安全的，哪些区域可能有雷，从而实现简单的扫雷游戏辅助功能。 请注意，在实际游戏中使用辅助工具可能涉及违反游戏规则的问题，仅用于技术学习和研究目的。</p>
<h2 id="使用注意事项与技巧"><a href="#使用注意事项与技巧" class="headerlink" title="使用注意事项与技巧"></a>使用注意事项与技巧</h2><p>防故障机制</p>
<p>PyAutoGUI 提供了自动防故障功能，默认情况下是开启的 。当鼠标移动到屏幕的左上角时，会触发FailSafeException异常，程序会停止执行，这可以防止程序出现异常情况时无法停止，导致不可预期的后果 。如果你确定自己的程序不会出现问题，或者在调试过程中不想被这个机制中断，可以通过以下方式禁用它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用自动防故障功能</span></span><br><span class="line">pyautogui.FAILSAFE = <span class="literal">False</span> </span><br></pre></td></tr></table></figure>

<p>不过，禁用故障保护可能会带来风险，因此请谨慎操作。 另外，为了避免操作速度过快导致程序出错或错过某些界面元素的响应，你可以设置停顿功能 。通过设置pyautogui.PAUSE变量，可以让每个 PyAutoGUI 函数调用在执行动作后暂停指定的秒数。例如，设置暂停时间为 1 秒：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置每次操作后暂停1秒</span></span><br><span class="line">pyautogui.PAUSE = <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p>这样，在执行诸如鼠标移动、点击、键盘输入等操作后，程序都会暂停 1 秒，给系统和其他应用程序足够的时间来响应。</p>
<h3 id="坐标定位技巧"><a href="#坐标定位技巧" class="headerlink" title="坐标定位技巧"></a>坐标定位技巧</h3><p>在使用 PyAutoGUI 进行鼠标操作时，准确获取屏幕坐标非常关键 。你可以使用pyautogui.position()函数来获取当前鼠标的坐标位置，返回一个包含横坐标和纵坐标的元组 。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前鼠标坐标</span></span><br><span class="line">x, y = pyautogui.position()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;当前鼠标坐标: (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p>另外，在进行图像识别定位时，为了提高定位的准确性和稳定性，可以设置locateOnScreen()函数的confidence参数 。该参数表示匹配的置信度，取值范围为 0 到 1，值越高表示匹配要求越严格 。例如，将置信度设置为 0.8：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在屏幕上查找图像，置信度为0.8</span></span><br><span class="line">location = pyautogui.locateOnScreen(<span class="string">&#x27;image.png&#x27;</span>, confidence=<span class="number">0.8</span>)</span><br><span class="line"><span class="keyword">if</span> location:</span><br><span class="line">	left, top, width, height = location</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;找到图像，位置为：(<span class="subst">&#123;left&#125;</span>, <span class="subst">&#123;top&#125;</span>)，宽度为：<span class="subst">&#123;width&#125;</span>，高度为：<span class="subst">&#123;height&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;未找到图像&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>当在不同分辨率的屏幕上运行自动化脚本时，由于相同的像素坐标在不同分辨率下代表的实际位置可能不同，会导致坐标不准确 。为了解决这个问题，可以使用pyautogui.size()函数获取当前屏幕的分辨率，并根据分辨率调整坐标 。例如，假设你希望在屏幕中心进行点击操作，无论屏幕分辨率如何变化，都可以这样实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取屏幕分辨率</span></span><br><span class="line">screen_width, screen_height = pyautogui.size()</span><br><span class="line"><span class="comment"># 计算屏幕中心坐标</span></span><br><span class="line">center_x = screen_width // <span class="number">2</span></span><br><span class="line">center_y = screen_height // <span class="number">2</span></span><br><span class="line"><span class="comment"># 移动鼠标到屏幕中心并点击</span></span><br><span class="line">pyautogui.click(center_x, center_y) </span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在使用 PyAutoGUI 时，可能会遇到各种异常情况 。除了前面提到的FailSafeException异常外，还可能遇到ImageNotFoundException异常，当使用locateOnScreen()等图像识别函数找不到指定图像时会抛出该异常 。你可以使用try - except语句来捕获并处理这些异常，使程序更加健壮 。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 在屏幕上查找图像</span></span><br><span class="line">    location = pyautogui.locateOnScreen(<span class="string">&#x27;icon.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> location:</span><br><span class="line">        x, y = pyautogui.center(location)</span><br><span class="line">        pyautogui.click(x, y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;未找到图像&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> pyautogui.ImageNotFoundException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;在屏幕上未找到指定图像&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> pyautogui.FailSafeException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;触发自动防故障机制，程序停止&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p>另外，在进行键盘输入操作时，如果目标窗口没有获得焦点，可能会导致输入内容没有出现在预期的位置 。为了避免这种情况，可以在执行键盘输入操作前，使用pyautogui.click()函数先将鼠标点击到目标窗口，使其获得焦点 。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设目标窗口的位置已知</span></span><br><span class="line">window_x, window_y = <span class="number">100</span>, <span class="number">100</span></span><br><span class="line"><span class="comment"># 点击目标窗口，使其获得焦点</span></span><br><span class="line">pyautogui.click(window_x, window_y)</span><br><span class="line"><span class="comment"># 进行键盘输入操作</span></span><br><span class="line">pyautogui.typewrite(<span class="string">&#x27;Hello, World!&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p>通过合理运用这些使用注意事项与技巧，可以让你在使用 PyAutoGUI 进行自动化任务时更加得心应手，提高脚本的稳定性和可靠性 。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/07/frp%EF%BC%9A%E4%B8%80%E6%AC%BE%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="l1n6yun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="l1n6yun's Blog">
      <meta itemprop="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | l1n6yun's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/07/frp%EF%BC%9A%E4%B8%80%E6%AC%BE%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">frp：一款强大的内网穿透代理工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-07 16:05:00" itemprop="dateCreated datePublished" datetime="2024-12-07T16:05:00+08:00">2024-12-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>frp（Fast Reverse Proxy）是一款开源的高性能内网穿透代理工具，它允许你将位于NAT或防火墙后面的本地服务器暴露到公网上。frp支持TCP、UDP、HTTP和HTTPS协议，使得内部服务可以通过域名被外部访问。此外，frp还提供了P2P连接模式，进一步增强了其灵活性和可用性。</p>
</blockquote>
<h2 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h2><p>frp以其简洁的设计和丰富的功能而闻名，以下是一些核心特性：</p>
<ol>
<li><strong>协议支持</strong>：支持TCP、UDP、HTTP和HTTPS协议，适用于多种网络环境。</li>
<li><strong>P2P连接</strong>：提供P2P连接模式，实现客户端间的直接通信，无需经过服务器。</li>
<li><strong>配置灵活</strong>：支持TOML、YAML和JSON格式的配置文件，方便不同用户的需求。</li>
<li><strong>安全性</strong>：支持Token和OIDC认证，增强连接的安全性。</li>
<li><strong>性能优化</strong>：提供TLS加密和数据压缩，保障数据传输的安全和效率。</li>
<li><strong>监控与日志</strong>：集成Prometheus监控，支持实时监控代理状态和流量。</li>
<li><strong>负载均衡</strong>：支持通过分组实现简单的负载均衡。</li>
<li><strong>健康检查</strong>：提供TCP和HTTP健康检查，确保服务的高可用性。</li>
<li><strong>自定义域名</strong>：支持自定义子域名，方便在共享服务器上区分不同用户的服务。</li>
<li><strong>插件系统</strong>：支持客户端和服务器端的插件扩展，增加了功能的灵活性和多样性。</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="步骤1：访问GitHub-Releases页面"><a href="#步骤1：访问GitHub-Releases页面" class="headerlink" title="步骤1：访问GitHub Releases页面"></a>步骤1：访问GitHub Releases页面</h3><p>打开浏览器，访问frp的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhdGVkaWVyL2ZycC9yZWxlYXNlcw==">GitHub Releases页面<i class="fa fa-external-link-alt"></i></span>。<br>在页面中，找到最新发布的版本，这通常会被标记为“Latest”或有相应的版本号。</p>
<h3 id="步骤2：下载二进制文件"><a href="#步骤2：下载二进制文件" class="headerlink" title="步骤2：下载二进制文件"></a>步骤2：下载二进制文件</h3><p>根据你的操作系统（Windows、Linux或macOS）和架构（如x86_64、arm等），选择相应的预编译二进制文件。</p>
<ul>
<li>对于Linux用户，你会找到以<code>linux_amd64</code>或<code>linux_arm64</code>等命名的压缩文件。</li>
<li>对于macOS用户，文件名通常包含<code>darwin</code>。</li>
<li>对于Windows用户，文件名会包含<code>windows_4.0</code>。<br>点击相应的文件名，下载到你的计算机上。</li>
</ul>
<h3 id="步骤3：解压缩文件"><a href="#步骤3：解压缩文件" class="headerlink" title="步骤3：解压缩文件"></a>步骤3：解压缩文件</h3><p>解压缩下载的文件。对于Linux和macOS用户，可以使用<code>tar</code>命令：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.39.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p>  对于Windows用户，可以使用文件资源管理器或第三方解压缩软件解压<code>.zip</code>文件。</p>
<h3 id="步骤4：移动到合适的目录"><a href="#步骤4：移动到合适的目录" class="headerlink" title="步骤4：移动到合适的目录"></a>步骤4：移动到合适的目录</h3><p>在解压缩的目录中，你会找到<code>frps</code>和<code>frpc</code>两个可执行文件，分别对应服务器端和客户端。</p>
<p>将<code>frps</code>和<code>frpc</code>移动到合适的目录，例如<code>/usr/local/bin</code>（需要管理员权限）：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> frps frpc /usr/local/bin/</span><br></pre></td></tr></table></figure>
<h3 id="步骤5：检查运行"><a href="#步骤5：检查运行" class="headerlink" title="步骤5：检查运行"></a>步骤5：检查运行</h3><p>在命令行中运行<code>frps -v</code>和<code>frpc -v</code>来检查二进制文件是否正确无误：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frps -v</span><br><span class="line">frpc -v</span><br></pre></td></tr></table></figure>
<p>  这将显示frp的版本信息，确认安装成功。</p>
<h2 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h2><p>frp的使用涉及两个主要组件：<code>frps</code>（服务器端）和<code>frpc</code>（客户端）。以下是一些基本的示例用法，帮助你快速开始使用frp。</p>
<h3 id="1-通过SSH访问内网计算机"><a href="#1-通过SSH访问内网计算机" class="headerlink" title="1. 通过SSH访问内网计算机"></a>1. 通过SSH访问内网计算机</h3><h4 id="服务端（frps）配置和启动："><a href="#服务端（frps）配置和启动：" class="headerlink" title="服务端（frps）配置和启动："></a>服务端（frps）配置和启动：</h4><ol>
<li>在拥有公网IP的服务器上配置<code>frps.toml</code>：</li>
</ol>
  <figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.toml</span></span><br><span class="line"><span class="attr">bindPort</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>启动<code>frps</code>：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.toml</span><br></pre></td></tr></table></figure>
<h4 id="客户端（frpc）配置和启动："><a href="#客户端（frpc）配置和启动：" class="headerlink" title="客户端（frpc）配置和启动："></a>客户端（frpc）配置和启动：</h4><ol start="3">
<li>在内网计算机上配置<code>frpc.toml</code>：</li>
</ol>
  <figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.toml</span></span><br><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;x.x.x.x&quot;</span>  <span class="comment"># 服务端公网IP</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;ssh&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;tcp&quot;</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remotePort</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>启动<code>frpc</code>：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.toml</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>通过SSH访问内网计算机：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 6000 用户名@服务端公网IP</span><br></pre></td></tr></table></figure>
<h3 id="2-使用自定义域名访问内网Web服务"><a href="#2-使用自定义域名访问内网Web服务" class="headerlink" title="2. 使用自定义域名访问内网Web服务"></a>2. 使用自定义域名访问内网Web服务</h3><h4 id="服务端（frps）配置和启动：-1"><a href="#服务端（frps）配置和启动：-1" class="headerlink" title="服务端（frps）配置和启动："></a>服务端（frps）配置和启动：</h4><ol>
<li>配置<code>frps.toml</code>：</li>
</ol>
  <figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.toml</span></span><br><span class="line"><span class="attr">bindPort</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">vhostHTTPPort</span> = <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>启动<code>frps</code>：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.toml</span><br></pre></td></tr></table></figure>
<h4 id="客户端（frpc）配置和启动：-1"><a href="#客户端（frpc）配置和启动：-1" class="headerlink" title="客户端（frpc）配置和启动："></a>客户端（frpc）配置和启动：</h4><ol start="3">
<li>配置<code>frpc.toml</code>：</li>
</ol>
  <figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.toml</span></span><br><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;x.x.x.x&quot;</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;web&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;http&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">customDomains</span> = [<span class="string">&quot;www.example.com&quot;</span>]</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>启动<code>frpc</code>：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.toml</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>配置域名解析：<br>  将<code>www.example.com</code>的A记录指向<code>frps</code>服务器的公网IP。</p>
</li>
<li><p>访问Web服务：<br>  通过浏览器访问<code>http://www.example.com:8080</code>。</p>
</li>
</ol>
<p>这些示例仅展示了frp的一小部分功能。frp的灵活性和强大的功能使其成为内网穿透的有力工具。你可以根据具体需求调整配置，实现更复杂的网络穿透和代理需求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/30/Docker-%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="l1n6yun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="l1n6yun's Blog">
      <meta itemprop="description" content="chitanda | 互联网 | 前端 | 宅 | 动漫 | 京阿尼">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | l1n6yun's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/30/Docker-%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Docker 国内镜像源配置指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-30 15:16:30" itemprop="dateCreated datePublished" datetime="2024-11-30T15:16:30+08:00">2024-11-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>随着 Docker 的广泛应用，越来越多的开发者和企业开始使用 Docker 来构建和部署应用。然而，由于网络原因，直接从 Docker Hub 拉取镜像可能会遇到速度慢或者不稳定的问题。为了解决这一问题，本文将介绍如何配置国内镜像源，以加速 Docker 镜像的拉取速度。</p>
</blockquote>
<h2 id="为什么需要配置国内镜像源？"><a href="#为什么需要配置国内镜像源？" class="headerlink" title="为什么需要配置国内镜像源？"></a>为什么需要配置国内镜像源？</h2><p>直接从 Docker Hub 拉取镜像可能会受到网络限制的影响，导致速度慢或者失败。配置国内镜像源可以有效地解决这一问题，提高镜像拉取的速度和稳定性。</p>
<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><p>以下是配置国内 Docker 镜像源的具体步骤：</p>
<h3 id="1-创建或修改-Docker-配置文件"><a href="#1-创建或修改-Docker-配置文件" class="headerlink" title="1. 创建或修改 Docker 配置文件"></a>1. 创建或修改 Docker 配置文件</h3><p>在 Linux 系统中，你需要修改或创建 <code>/etc/docker/daemon.json</code> 文件。如果文件不存在，你可以使用以下命令创建它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://docker.1ms.run&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://doublezonline.cloud&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dislabaiot.xyz&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.fxxk.dedyn.io&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dockerpull.org&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.unsee.tech&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://hub.rat.dev&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.1panel.live&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.nastool.de&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.zhai.cm&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.5z5f.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://a.ussh.net&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.udayun.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://hub.geekery.cn&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="2-重启-Docker-服务"><a href="#2-重启-Docker-服务" class="headerlink" title="2. 重启 Docker 服务"></a>2. 重启 Docker 服务</h3><p>修改配置文件后，需要重启 Docker 服务以使配置生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="3-验证配置是否成功"><a href="#3-验证配置是否成功" class="headerlink" title="3. 验证配置是否成功"></a>3. 验证配置是否成功</h4><p>使用以下命令检查 Docker 信息，确认镜像源是否已经更改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>以上步骤可以帮助你配置国内镜像源，以加速 Docker 镜像的拉取速度。请根据实际情况选择可用的镜像源进行配置。这些镜像源均来自最新的搜索结果，确保了时效性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">l1n6yun</span>
  </div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
