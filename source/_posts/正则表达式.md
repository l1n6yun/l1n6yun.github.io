title: 正则表达式
author: l1n6yun
tags: []
categories: []
date: 2018-03-10 22:25:00
---
正则表达式(Regular Expression)是一种文本模式，包含普通字符（列如，a 到 z 之间的字母）和特殊字符（元字符）。

正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。

## 正则表达式 - 语法

### 普通字符串

| 字符        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| [ABC]       | 匹配 `[...]` 中的所有字符。例如用 `/[lny]/g` 来匹配字符串 "l1n6yun",可以匹配到 `l,n,y,n` 。 |
| [!ABC]      | 匹配除了 `[!...]` 中的所有字符。例如 `/[^lny]/g` 来匹配字符串 "l1n6yun",可以匹配到 `1,6,u` 。 |
| [A-Z] [a-z] | `[A-Z]` 表示一个区间，匹配所有大写字母。`[a-z]` 表示匹配所有小写字母。 |
| .           | 匹配除换行符 ( `\r`、`\n`) 之外的任何单字符，相当于 `[^\r\n]` |
| [\s\S]      | 匹配所有。`\s` 是匹配所有空白符，包含换行，`\S` 非空白符，不包含换行 |
| \w          | 匹配字母、数字、下划线。等价于 `[A-Za-z0-9_]`                |

### 非打印字符

| 字符 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| \cx  | 匹配由x指明的控制字符。例如， `\cM` 匹配一个 Control-M 或回车符。`x` 的值必须为 `A-Z` 或 `a-z` 之一。否则，将 `c` 视为一个原义的 'c' 字符。 |
| \f   | 匹配一个换页符。等价于 `\x0c` 和 `\cL`。                     |
| \n   | 匹配一个换行符。等价于 `\x0a` 和 `\cJ`。                     |
| \r   | 匹配一个回车符。等价于 `\x0d` 和 `\cM`。                     |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 `[\f\n\r\t\v]`。注意 Unicode 正则表达式会匹配全角空格符。 |
| \S   | 匹配任何非空白字符。等价于 `[^ \f\n\r\t\v]`。                |
| \t   | 匹配一个制表符。等价于 `\x09` 和 `\cI`。                     |
| \v   | 匹配一个垂直制表符。等价于 `\x0b` 和 `\cK`。                 |
| \xn  | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。 |
| \n   | 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |
| \nm  | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 |
| \nml | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |
| \un  | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 |

### 特殊字符

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| $        | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。 |
| ( )      | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
| *        | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。     |
| +        | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。     |
| .        | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。    |
| [        | 标记一个中括号表达式的开始。要匹配 [，请使用 \[。            |
| ?        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 |
| \        | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| ^        | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {        | 标记限定符表达式的开始。要匹配 {，请使用 \{。                |
| \|       | 指明两项之间的一个选择。要匹配 \|，请使用 \|。               |

### 限定符

| 字符  | 描述                                                   |
| :---- | :----------------------------------------------------- |
| *     | 匹配前面的子表达式零次或多次。***** 等价于 **{0,}**。  |
| +     | 匹配前面的子表达式一次或多次。**+** 等价于 **{1,}**。  |
| ?     | 匹配前面的子表达式零次或一次。**?** 等价于 **{0,1}**。 |
| {n}   | n 是一个非负整数。匹配确定的 **n** 次。                |
| {n,}  | n 是一个非负整数。至少匹配n 次。                       |
| {n,m} | m 和 n 均为非负整数，其中 n <= m。                     |

`*`  和 `+` 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 `?` 就可以实现非贪婪或最小的匹配。

### 定位符

定位符使您能够将正则表达式固定到行首或行尾。他们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即字与空格间的位置。例如"Hello World"，结果"\dHello\d \dWorld\d" |
| \B   | 非单词边界匹配。例如"Hello World"，结果"H\Be\Bl\Bl\Bo W\Bo\Br\Bl\Bd" |

### 选择

用圆括号 `()` 将所有选择项括起来，相邻的选择项之间用 `|` 分割。

```
/([1-9])([a-z]+)/g
```

| 表达式        | 描述                      |
| ------------- | ------------------------- |
| exp1(?=exp2)  | 查找 exp2 前面的 exp1     |
| (?<=exp2)exp1 | 查找 exp2 后面的 exp1     |
| exp1(?!exp2)  | 查找后面不是 exp2 的 exp1 |
| (?<!exp2)exp1 | 查找前面不是 exp2 的 exp1 |

### 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 **\n** 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。

可以使用非捕获元字符 **?:**、**?=** 或 **?!** 来重写捕获，忽略对相关匹配的保存。

反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：

```
Is is the cost of of gasoline going up up?
```

上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：

```js
var str = "Is is the cost of of gasoline going up up";
var patt1 = /\b([a-z]+) \1\b/igm;
document.write(str.match(patt1));
```

捕获的表达式，正如 **[a-z]+** 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。**\1** 指定第一个子匹配项。

单词边界元字符确保只检测整个单词。否则，诸如 "is issued" 或 "this is" 之类的词组将不能正确地被此表达式识别。

正则表达式后面的全局标记 **g** 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。

表达式的结尾处的不区分大小写 **i** 标记指定不区分大小写。

多行标记 **m** 指定换行符的两边可能出现潜在的匹配。

## 正则表达式 - 修饰符

标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。

```
/pattern/flags
```

下表列出了正则表达式常用的修饰符

| 修饰符 | 含义                                   | 描述                                                         |
| :----- | :------------------------------------- | :----------------------------------------------------------- |
| i      | ignore - 不区分大小写                  | 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 |
| g      | global - 全局匹配                      | 查找所有的匹配项。                                           |
| m      | multi line - 多行匹配                  | 使边界字符 **^** 和 **$** 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 |
| s      | 特殊字符圆点 **.** 中包含换行符 **\n** | 默认情况下的圆点 **.** 是匹配除换行符 **\n** 之外的任何字符，加上 **s** 修饰符之后, **.** 中包含换行符 \n。 |